# Bubble Sort

Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

## How It Works

1. Compare adjacent elements
2. Swap if they are in wrong order
3. Repeat for all pairs
4. After each pass, the largest element "bubbles" to the end
5. Continue until no swaps are needed

```
Initial: [64, 34, 25, 12]

Pass 1:
  [64, 34, ...] → swap → [34, 64, 25, 12]
  [64, 25, ...] → swap → [34, 25, 64, 12]
  [64, 12, ...] → swap → [34, 25, 12, 64]  ← 64 bubbled to end

Pass 2:
  [34, 25, ...] → swap → [25, 34, 12, 64]
  [34, 12, ...] → swap → [25, 12, 34, 64]  ← 34 in place

Pass 3:
  [25, 12, ...] → swap → [12, 25, 34, 64]  ← Done!
```

---

## Implementation

```multi
---javascript
function bubbleSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n; i++) {
        let swapped = false;
        
        // Last i elements are already in place
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                swapped = true;
            }
        }
        
        // If no swaps, array is sorted
        if (!swapped) break;
    }
    
    return arr;
}

// Example
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort(arr));
// [11, 12, 22, 25, 34, 64, 90]
---python
def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        swapped = False
        
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                # Swap elements
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # If no swaps, array is sorted
        if not swapped:
            break
    
    return arr

# Example
arr = [64, 34, 25, 12, 22, 11, 90]
print(bubble_sort(arr))
# [11, 12, 22, 25, 34, 64, 90]
---java
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n; i++) {
        boolean swapped = false;
        
        // Last i elements are already in place
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        
        // If no swaps, array is sorted
        if (!swapped) break;
    }
}

// Example
int[] arr = {64, 34, 25, 12, 22, 11, 90};
bubbleSort(arr);
// arr = [11, 12, 22, 25, 34, 64, 90]
---cpp
void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n; i++) {
        bool swapped = false;
        
        // Last i elements are already in place
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Swap elements
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        
        // If no swaps, array is sorted
        if (!swapped) break;
    }
}

// Example
vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
bubbleSort(arr);
// arr = [11, 12, 22, 25, 34, 64, 90]
```

---

## Step-by-Step Example

```
Initial Array: [64, 34, 25, 12, 22, 11, 90]

Pass 1: [34, 25, 12, 22, 11, 64, 90]  ← 90 bubbles to end
Pass 2: [25, 12, 22, 11, 34, 64, 90]  ← 64 in place
Pass 3: [12, 22, 11, 25, 34, 64, 90]  ← 34 in place
Pass 4: [12, 11, 22, 25, 34, 64, 90]  ← 25 in place
Pass 5: [11, 12, 22, 25, 34, 64, 90]  ← Sorted!
```

---

## Time & Space Complexity

| Case | Time | Space |
|------|------|-------|
| Best | O(n) | O(1) |
| Average | O(n²) | O(1) |
| Worst | O(n²) | O(1) |

- **Best Case O(n):** Array is already sorted (with optimization)
- **Worst Case O(n²):** Array is reverse sorted
- **Space O(1):** In-place sorting, only uses constant extra space

---

## Recursive Implementation

```multi
---javascript
function bubbleSortRecursive(arr, n = arr.length) {
    // Base case: single element or empty
    if (n <= 1) return arr;
    
    // One pass of bubble sort
    for (let i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
        }
    }
    
    // Recurse for remaining elements
    return bubbleSortRecursive(arr, n - 1);
}
---python
def bubble_sort_recursive(arr, n=None):
    if n is None:
        n = len(arr)
    
    # Base case: single element or empty
    if n <= 1:
        return arr
    
    # One pass of bubble sort
    for i in range(n - 1):
        if arr[i] > arr[i + 1]:
            arr[i], arr[i + 1] = arr[i + 1], arr[i]
    
    # Recurse for remaining elements
    return bubble_sort_recursive(arr, n - 1)
---java
public static void bubbleSortRecursive(int[] arr, int n) {
    // Base case: single element or empty
    if (n <= 1) return;
    
    // One pass of bubble sort
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            int temp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = temp;
        }
    }
    
    // Recurse for remaining elements
    bubbleSortRecursive(arr, n - 1);
}
---cpp
void bubbleSortRecursive(vector<int>& arr, int n) {
    // Base case: single element or empty
    if (n <= 1) return;
    
    // One pass of bubble sort
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            swap(arr[i], arr[i + 1]);
        }
    }
    
    // Recurse for remaining elements
    bubbleSortRecursive(arr, n - 1);
}
```

---

## When to Use Bubble Sort

| Scenario | Use? |
|----------|------|
| Educational purposes | ✅ Yes |
| Small datasets (<20 elements) | ✅ Yes |
| Nearly sorted data | ✅ Yes (with optimization) |
| Large datasets | ❌ No |
| Performance-critical code | ❌ No |

---

## Advantages

- ✅ Simple to understand and implement
- ✅ In-place sorting (O(1) space)
- ✅ Stable (maintains relative order of equal elements)
- ✅ Adaptive (can detect sorted array early)

## Disadvantages

- ❌ Very slow for large arrays: O(n²)
- ❌ Many comparisons and swaps
- ❌ Not practical for real-world applications

---

## Comparison with Other Sorting Algorithms

| Algorithm | Best | Average | Worst | Space | Stable |
|-----------|------|---------|-------|-------|--------|
| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) | Yes |
| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) | No |
| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) | Yes |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) | Yes |
| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) | No |

---

## Key Takeaways

1. **Simple but slow** - Great for learning, not for production
2. **Optimization matters** - Early termination improves best case to O(n)
3. **In-place and stable** - Good properties despite poor performance
4. **Know when to use** - Small or nearly sorted arrays only
