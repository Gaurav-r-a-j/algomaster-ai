# Selection Sort

Selection Sort works by repeatedly finding the minimum element from the unsorted portion and placing it at the beginning.

## How It Works

1. Find the minimum element in the unsorted array
2. Swap it with the first unsorted element
3. Move the boundary of sorted/unsorted array one position right
4. Repeat until the entire array is sorted

## Visual Representation

```
Initial: [64, 25, 12, 22, 11]

Pass 1: Find min in [64, 25, 12, 22, 11] → 11 at index 4
        Swap with index 0
        [11, 25, 12, 22, 64]
        [sorted | unsorted]

Pass 2: Find min in [25, 12, 22, 64] → 12 at index 2
        Swap with index 1
        [11, 12, 25, 22, 64]

Pass 3: Find min in [25, 22, 64] → 22 at index 3
        Swap with index 2
        [11, 12, 22, 25, 64]

Pass 4: Find min in [25, 64] → 25 at index 3
        Already in place
        [11, 12, 22, 25, 64]

Final:  [11, 12, 22, 25, 64] ✓
```

## Implementation

```multi
[javascript]
function selectionSort(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n; i++) {
        // Find minimum element in remaining unsorted array
        let minIdx = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // Swap the found minimum with the first element
        if (minIdx !== i) {
            [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
        }
    }
    
    return arr;
}

// Example
const arr = [64, 25, 12, 22, 11];
console.log(selectionSort(arr));  // [11, 12, 22, 25, 64]

[python]
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # Find minimum element in remaining unsorted array
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # Swap the found minimum with the first element
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# Example
arr = [64, 25, 12, 22, 11]
sorted_arr = selection_sort(arr)
print(sorted_arr)  # [11, 12, 22, 25, 64]

[java]
public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n; i++) {
            // Find minimum element in remaining unsorted array
            int minIdx = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            
            // Swap the found minimum with the first element
            if (minIdx != i) {
                int temp = arr[i];
                arr[i] = arr[minIdx];
                arr[minIdx] = temp;
            }
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        selectionSort(arr);
        // arr is now [11, 12, 22, 25, 64]
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

[cpp]
#include <iostream>
#include <vector>

void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n; i++) {
        // Find minimum element in remaining unsorted array
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // Swap the found minimum with the first element
        if (minIdx != i) {
            std::swap(arr[i], arr[minIdx]);
        }
    }
}

int main() {
    std::vector<int> arr = {64, 25, 12, 22, 11};
    selectionSort(arr);
    // arr is now {11, 12, 22, 25, 64}
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
```

## Time Complexity

| Case | Complexity | Description |
|------|------------|-------------|
| Best | O(n²) | Still needs to check all elements |
| Average | O(n²) | Same for all inputs |
| Worst | O(n²) | Same for all inputs |

**Note:** Selection sort always performs the same number of comparisons regardless of input.

## Space Complexity

O(1) - In-place sorting algorithm.

## Characteristics

- **Not Stable:** May change relative order of equal elements
- **Not Adaptive:** Performance doesn't improve on nearly sorted data
- **In-place:** Only uses O(1) extra space
- **Minimum Swaps:** Only O(n) swaps in worst case

## Variations

### Selection Sort (Descending Order)

```multi
[javascript]
function selectionSortDesc(arr) {
    const n = arr.length;
    
    for (let i = 0; i < n; i++) {
        // Find maximum element in remaining unsorted array
        let maxIdx = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] > arr[maxIdx]) {
                maxIdx = j;
            }
        }
        
        [arr[i], arr[maxIdx]] = [arr[maxIdx], arr[i]];
    }
    
    return arr;
}

// Example
console.log(selectionSortDesc([64, 25, 12, 22, 11]));
// [64, 25, 22, 12, 11]

[python]
def selection_sort_desc(arr):
    n = len(arr)
    
    for i in range(n):
        # Find maximum element in remaining unsorted array
        max_idx = i
        for j in range(i + 1, n):
            if arr[j] > arr[max_idx]:
                max_idx = j
        
        arr[i], arr[max_idx] = arr[max_idx], arr[i]
    
    return arr

# Example
print(selection_sort_desc([64, 25, 12, 22, 11]))
# [64, 25, 22, 12, 11]

[java]
public static void selectionSortDesc(int[] arr) {
    int n = arr.length;
    
    for (int i = 0; i < n; i++) {
        // Find maximum element in remaining unsorted array
        int maxIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[maxIdx]) {
                maxIdx = j;
            }
        }
        
        int temp = arr[i];
        arr[i] = arr[maxIdx];
        arr[maxIdx] = temp;
    }
}

// Example: [64, 25, 12, 22, 11] → [64, 25, 22, 12, 11]

[cpp]
void selectionSortDesc(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n; i++) {
        // Find maximum element in remaining unsorted array
        int maxIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[maxIdx]) {
                maxIdx = j;
            }
        }
        
        std::swap(arr[i], arr[maxIdx]);
    }
}

// Example: [64, 25, 12, 22, 11] → [64, 25, 22, 12, 11]
```

### Double Selection Sort (Cocktail Selection Sort)

Finds both minimum and maximum in each pass.

```multi
[javascript]
function doubleSelectionSort(arr) {
    let left = 0;
    let right = arr.length - 1;
    
    while (left < right) {
        let minIdx = left;
        let maxIdx = right;
        
        for (let i = left; i <= right; i++) {
            if (arr[i] < arr[minIdx]) minIdx = i;
            if (arr[i] > arr[maxIdx]) maxIdx = i;
        }
        
        // Swap minimum to left
        [arr[left], arr[minIdx]] = [arr[minIdx], arr[left]];
        
        // If maxIdx was at left, it's now at minIdx
        if (maxIdx === left) maxIdx = minIdx;
        
        // Swap maximum to right
        [arr[right], arr[maxIdx]] = [arr[maxIdx], arr[right]];
        
        left++;
        right--;
    }
    
    return arr;
}

[python]
def double_selection_sort(arr):
    left = 0
    right = len(arr) - 1
    
    while left < right:
        min_idx = left
        max_idx = right
        
        for i in range(left, right + 1):
            if arr[i] < arr[min_idx]:
                min_idx = i
            if arr[i] > arr[max_idx]:
                max_idx = i
        
        # Swap minimum to left
        arr[left], arr[min_idx] = arr[min_idx], arr[left]
        
        # If max_idx was at left, it's now at min_idx
        if max_idx == left:
            max_idx = min_idx
        
        # Swap maximum to right
        arr[right], arr[max_idx] = arr[max_idx], arr[right]
        
        left += 1
        right -= 1
    
    return arr

[java]
public static void doubleSelectionSort(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    
    while (left < right) {
        int minIdx = left;
        int maxIdx = right;
        
        for (int i = left; i <= right; i++) {
            if (arr[i] < arr[minIdx]) minIdx = i;
            if (arr[i] > arr[maxIdx]) maxIdx = i;
        }
        
        // Swap minimum to left
        int temp = arr[left];
        arr[left] = arr[minIdx];
        arr[minIdx] = temp;
        
        // If maxIdx was at left, it's now at minIdx
        if (maxIdx == left) maxIdx = minIdx;
        
        // Swap maximum to right
        temp = arr[right];
        arr[right] = arr[maxIdx];
        arr[maxIdx] = temp;
        
        left++;
        right--;
    }
}

[cpp]
void doubleSelectionSort(std::vector<int>& arr) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        int minIdx = left;
        int maxIdx = right;
        
        for (int i = left; i <= right; i++) {
            if (arr[i] < arr[minIdx]) minIdx = i;
            if (arr[i] > arr[maxIdx]) maxIdx = i;
        }
        
        // Swap minimum to left
        std::swap(arr[left], arr[minIdx]);
        
        // If maxIdx was at left, it's now at minIdx
        if (maxIdx == left) maxIdx = minIdx;
        
        // Swap maximum to right
        std::swap(arr[right], arr[maxIdx]);
        
        left++;
        right--;
    }
}
```

---

## When to Use

- Small arrays
- When memory writes are expensive (minimal swaps)
- Educational purposes
- When simplicity is needed

## Advantages

- Simple to understand
- In-place sorting
- Minimal memory writes (O(n) swaps)
- Predictable behavior (always O(n²))

## Disadvantages

- Slow: O(n²) time complexity
- Not stable
- Not adaptive
- Many comparisons required

## Comparison with Other Sorts

| Algorithm | Best | Average | Worst | Stable | Swaps |
|-----------|------|---------|-------|--------|-------|
| Selection Sort | O(n²) | O(n²) | O(n²) | No | O(n) |
| Bubble Sort | O(n) | O(n²) | O(n²) | Yes | O(n²) |
| Insertion Sort | O(n) | O(n²) | O(n²) | Yes | O(n²) |

## Key Takeaways

1. **Simple but slow** - Always O(n²) regardless of input
2. **Minimal swaps** - Only O(n) swaps needed
3. **Not stable** - May change relative order of equal elements
4. **Use for**: Small arrays or when minimizing writes matters
