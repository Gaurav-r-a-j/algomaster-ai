# Insertion Sort

Insertion Sort builds the sorted array one element at a time, similar to how you sort playing cards in your hands.

## How It Works

1. Start with the second element (first is already "sorted")
2. Compare with elements in the sorted portion
3. Shift larger elements to the right
4. Insert the current element in its correct position
5. Repeat for all elements

## Visual Representation

```
Initial: [5, 2, 4, 6, 1, 3]

Pass 1: [5, 2, 4, 6, 1, 3]   key = 2
            ^
        [2, 5, 4, 6, 1, 3]   2 inserted before 5

Pass 2: [2, 5, 4, 6, 1, 3]   key = 4
               ^
        [2, 4, 5, 6, 1, 3]   4 inserted between 2 and 5

Pass 3: [2, 4, 5, 6, 1, 3]   key = 6
                  ^
        [2, 4, 5, 6, 1, 3]   6 stays in place

Pass 4: [2, 4, 5, 6, 1, 3]   key = 1
                     ^
        [1, 2, 4, 5, 6, 3]   1 inserted at beginning

Pass 5: [1, 2, 4, 5, 6, 3]   key = 3
                        ^
        [1, 2, 3, 4, 5, 6]   3 inserted between 2 and 4

Final:  [1, 2, 3, 4, 5, 6]
```

## Implementation

```multi
[javascript]
function insertionSort(arr) {
    const n = arr.length;
    
    for (let i = 1; i < n; i++) {
        const key = arr[i];  // Element to be inserted
        let j = i - 1;
        
        // Move elements greater than key one position ahead
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // Insert key in correct position
        arr[j + 1] = key;
    }
    
    return arr;
}

// Example
const arr = [12, 11, 13, 5, 6];
console.log(insertionSort(arr));  // [5, 6, 11, 12, 13]

[python]
def insertion_sort(arr):
    n = len(arr)
    
    for i in range(1, n):
        key = arr[i]  # Element to be inserted
        j = i - 1
        
        # Move elements greater than key one position ahead
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        # Insert key in correct position
        arr[j + 1] = key
    
    return arr

# Example
arr = [12, 11, 13, 5, 6]
sorted_arr = insertion_sort(arr)
print(sorted_arr)  # [5, 6, 11, 12, 13]

[java]
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];  // Element to be inserted
            int j = i - 1;
            
            // Move elements greater than key one position ahead
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            // Insert key in correct position
            arr[j + 1] = key;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        insertionSort(arr);
        // arr is now [5, 6, 11, 12, 13]
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

[cpp]
#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // Element to be inserted
        int j = i - 1;
        
        // Move elements greater than key one position ahead
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // Insert key in correct position
        arr[j + 1] = key;
    }
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6};
    insertionSort(arr);
    // arr is now {5, 6, 11, 12, 13}
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
```

## Time Complexity

| Case | Complexity | Description |
|------|------------|-------------|
| Best | O(n) | Array is already sorted |
| Average | O(n²) | Random order |
| Worst | O(n²) | Array is reverse sorted |

## Space Complexity

O(1) - In-place sorting algorithm.

## Characteristics

- **Stable:** Maintains relative order of equal elements
- **Adaptive:** Efficient for nearly sorted data
- **In-place:** Only uses O(1) extra space
- **Online:** Can sort as it receives input

## Variations

### Binary Insertion Sort

Uses binary search to find the correct position for insertion.

```multi
[javascript]
function binaryInsertionSort(arr) {
    const binarySearch = (arr, item, low, high) => {
        while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            if (arr[mid] === item) return mid + 1;
            if (arr[mid] < item) low = mid + 1;
            else high = mid - 1;
        }
        return low;
    };
    
    for (let i = 1; i < arr.length; i++) {
        const key = arr[i];
        const pos = binarySearch(arr, key, 0, i - 1);
        
        // Shift elements and insert
        for (let j = i - 1; j >= pos; j--) {
            arr[j + 1] = arr[j];
        }
        arr[pos] = key;
    }
    
    return arr;
}

[python]
import bisect

def binary_insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        # Find position using binary search
        pos = bisect.bisect_left(arr, key, 0, i)
        
        # Shift elements and insert
        for j in range(i - 1, pos - 1, -1):
            arr[j + 1] = arr[j]
        arr[pos] = key
    
    return arr

# Example
arr = [12, 11, 13, 5, 6]
print(binary_insertion_sort(arr))  # [5, 6, 11, 12, 13]

[java]
import java.util.Arrays;

public static void binaryInsertionSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int pos = Arrays.binarySearch(arr, 0, i, key);
        if (pos < 0) pos = -(pos + 1);
        
        // Shift elements and insert
        for (int j = i - 1; j >= pos; j--) {
            arr[j + 1] = arr[j];
        }
        arr[pos] = key;
    }
}

[cpp]
#include <algorithm>
#include <vector>

void binaryInsertionSort(std::vector<int>& arr) {
    for (int i = 1; i < arr.size(); i++) {
        int key = arr[i];
        auto pos = std::lower_bound(arr.begin(), arr.begin() + i, key);
        int posIdx = pos - arr.begin();
        
        // Shift elements and insert
        for (int j = i - 1; j >= posIdx; j--) {
            arr[j + 1] = arr[j];
        }
        arr[posIdx] = key;
    }
}
```

### Insertion Sort for Linked List

```multi
[javascript]
function insertionSortList(head) {
    if (!head || !head.next) return head;
    
    const dummy = { val: -Infinity, next: null };
    let curr = head;
    
    while (curr) {
        const next = curr.next;
        let prev = dummy;
        
        // Find insertion position
        while (prev.next && prev.next.val < curr.val) {
            prev = prev.next;
        }
        
        // Insert node
        curr.next = prev.next;
        prev.next = curr;
        curr = next;
    }
    
    return dummy.next;
}

[python]
def insertion_sort_list(head):
    if not head or not head.next:
        return head
    
    dummy = ListNode(-float('inf'))
    curr = head
    
    while curr:
        next_node = curr.next
        prev = dummy
        
        # Find insertion position
        while prev.next and prev.next.val < curr.val:
            prev = prev.next
        
        # Insert node
        curr.next = prev.next
        prev.next = curr
        curr = next_node
    
    return dummy.next

[java]
public ListNode insertionSortList(ListNode head) {
    if (head == null || head.next == null) return head;
    
    ListNode dummy = new ListNode(Integer.MIN_VALUE);
    ListNode curr = head;
    
    while (curr != null) {
        ListNode next = curr.next;
        ListNode prev = dummy;
        
        // Find insertion position
        while (prev.next != null && prev.next.val < curr.val) {
            prev = prev.next;
        }
        
        // Insert node
        curr.next = prev.next;
        prev.next = curr;
        curr = next;
    }
    
    return dummy.next;
}

[cpp]
ListNode* insertionSortList(ListNode* head) {
    if (!head || !head->next) return head;
    
    ListNode dummy(INT_MIN);
    ListNode* curr = head;
    
    while (curr) {
        ListNode* next = curr->next;
        ListNode* prev = &dummy;
        
        // Find insertion position
        while (prev->next && prev->next->val < curr->val) {
            prev = prev->next;
        }
        
        // Insert node
        curr->next = prev->next;
        prev->next = curr;
        curr = next;
    }
    
    return dummy.next;
}
```

---

## When to Use

- Small datasets (<50 elements)
- Nearly sorted data
- When stability is required
- Hybrid algorithms (used in Timsort)

## Advantages

- Simple implementation
- Efficient for small arrays
- Adaptive (fast on nearly sorted data)
- Stable sorting
- In-place
- Online algorithm

## Disadvantages

- Slow for large arrays: O(n²)
- Many shifts required in worst case

## Real-World Use

- Used in Timsort (Python's default sort)
- Efficient for small subarrays in hybrid sorts
- Good for real-time data where elements arrive one by one

## Key Takeaways

1. **Build sorted portion incrementally** - Insert each element in its correct position
2. **Best for small or nearly sorted data** - O(n) best case
3. **Stable and in-place** - Maintains order, uses O(1) space
4. **Used in hybrid algorithms** - Timsort uses it for small subarrays
