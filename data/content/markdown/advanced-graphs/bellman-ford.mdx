# Bellman-Ford Algorithm

Bellman-Ford finds shortest paths from a source vertex to all other vertices, even with **negative edge weights**. It can also detect negative cycles.

## Visual Example

```
Graph with negative edge:
    A ---(4)---> B
    |           |
   (2)        (-3)
    |           |
    v           v
    C ---(1)---> D

From A:
  After pass 1: A=0, B=4, C=2, D=5
  After pass 2: A=0, B=4, C=2, D=1 (via A→B→D with -3)
  After pass 3: No changes (stable)
```

## How It Works

1. Initialize distances: source = 0, others = infinity
2. Relax all edges V-1 times
3. Check for negative cycles with one more iteration

## Implementation

```multi
[javascript]
function bellmanFord(edges, n, source) {
    // edges: array of [u, v, weight]
    const dist = new Array(n).fill(Infinity);
    dist[source] = 0;
    
    // Relax all edges V-1 times
    for (let i = 0; i < n - 1; i++) {
        for (const [u, v, weight] of edges) {
            if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    // Check for negative cycles
    for (const [u, v, weight] of edges) {
        if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
            return null;  // Negative cycle detected
        }
    }
    
    return dist;
}

// Usage
const edges = [[0, 1, 4], [0, 2, 2], [1, 3, -3], [2, 3, 1]];
console.log(bellmanFord(edges, 4, 0));  // [0, 4, 2, 1]

[python]
def bellman_ford(edges, n, source):
    """
    Bellman-Ford algorithm for shortest paths.
    Works with negative edge weights.
    Time: O(V × E)
    """
    # edges: list of (u, v, weight)
    dist = [float('inf')] * n
    dist[source] = 0
    
    # Relax all edges V-1 times
    for _ in range(n - 1):
        for u, v, weight in edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
    
    # Check for negative cycles
    for u, v, weight in edges:
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            return None  # Negative cycle detected
    
    return dist

# Usage
edges = [(0, 1, 4), (0, 2, 2), (1, 3, -3), (2, 3, 1)]
print(bellman_ford(edges, 4, 0))  # [0, 4, 2, 1]

[java]
public int[] bellmanFord(int[][] edges, int n, int source) {
    int[] dist = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    dist[source] = 0;
    
    // Relax all edges V-1 times
    for (int i = 0; i < n - 1; i++) {
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (dist[u] != Integer.MAX_VALUE && 
                dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    // Check for negative cycles
    for (int[] edge : edges) {
        int u = edge[0], v = edge[1], weight = edge[2];
        if (dist[u] != Integer.MAX_VALUE && 
            dist[u] + weight < dist[v]) {
            return null;  // Negative cycle detected
        }
    }
    
    return dist;
}

[cpp]
#include <vector>
#include <limits>
#include <optional>

std::optional<std::vector<int>> bellmanFord(
    std::vector<std::vector<int>>& edges, int n, int source
) {
    std::vector<int> dist(n, INT_MAX);
    dist[source] = 0;
    
    // Relax all edges V-1 times
    for (int i = 0; i < n - 1; i++) {
        for (auto& edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    // Check for negative cycles
    for (auto& edge : edges) {
        int u = edge[0], v = edge[1], weight = edge[2];
        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
            return std::nullopt;  // Negative cycle detected
        }
    }
    
    return dist;
}
```

## With Path Reconstruction

```multi
[javascript]
function bellmanFordPath(edges, n, source, target) {
    const dist = new Array(n).fill(Infinity);
    const parent = new Array(n).fill(-1);
    dist[source] = 0;
    
    for (let i = 0; i < n - 1; i++) {
        for (const [u, v, weight] of edges) {
            if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
        }
    }
    
    // Check for negative cycle
    for (const [u, v, weight] of edges) {
        if (dist[u] !== Infinity && dist[u] + weight < dist[v]) {
            return { distance: null, path: null };
        }
    }
    
    // Reconstruct path
    const path = [];
    let current = target;
    while (current !== -1) {
        path.push(current);
        current = parent[current];
    }
    
    return { distance: dist[target], path: path.reverse() };
}

[python]
def bellman_ford_path(edges, n, source, target):
    dist = [float('inf')] * n
    dist[source] = 0
    parent = [-1] * n
    
    for _ in range(n - 1):
        for u, v, weight in edges:
            if dist[u] != float('inf') and dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                parent[v] = u
    
    # Check for negative cycle
    for u, v, weight in edges:
        if dist[u] != float('inf') and dist[u] + weight < dist[v]:
            return None, None
    
    # Reconstruct path
    path = []
    current = target
    while current != -1:
        path.append(current)
        current = parent[current]
    
    return dist[target], path[::-1]

[java]
public Object[] bellmanFordPath(int[][] edges, int n, int source, int target) {
    int[] dist = new int[n];
    int[] parent = new int[n];
    Arrays.fill(dist, Integer.MAX_VALUE);
    Arrays.fill(parent, -1);
    dist[source] = 0;
    
    for (int i = 0; i < n - 1; i++) {
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (dist[u] != Integer.MAX_VALUE && 
                dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
        }
    }
    
    // Check for negative cycle
    for (int[] edge : edges) {
        int u = edge[0], v = edge[1], weight = edge[2];
        if (dist[u] != Integer.MAX_VALUE && 
            dist[u] + weight < dist[v]) {
            return null;
        }
    }
    
    // Reconstruct path
    List<Integer> path = new ArrayList<>();
    int current = target;
    while (current != -1) {
        path.add(0, current);
        current = parent[current];
    }
    
    return new Object[]{dist[target], path};
}

[cpp]
std::optional<std::pair<int, std::vector<int>>> bellmanFordPath(
    std::vector<std::vector<int>>& edges, int n, int source, int target
) {
    std::vector<int> dist(n, INT_MAX);
    std::vector<int> parent(n, -1);
    dist[source] = 0;
    
    for (int i = 0; i < n - 1; i++) {
        for (auto& edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
        }
    }
    
    // Check for negative cycle
    for (auto& edge : edges) {
        int u = edge[0], v = edge[1], weight = edge[2];
        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
            return std::nullopt;
        }
    }
    
    // Reconstruct path
    std::vector<int> path;
    int current = target;
    while (current != -1) {
        path.push_back(current);
        current = parent[current];
    }
    std::reverse(path.begin(), path.end());
    
    return std::make_pair(dist[target], path);
}
```

## Time Complexity

| Metric | Complexity |
|--------|------------|
| Time | O(V × E) |
| Space | O(V) |

## Comparison with Dijkstra

| Feature | Dijkstra | Bellman-Ford |
|---------|----------|--------------|
| Negative weights | No | Yes |
| Negative cycles | Cannot detect | Detects |
| Time complexity | O((V+E) log V) | O(V × E) |
| Use case | Non-negative graphs | Any weighted graph |

## Detect Negative Cycle

```multi
[javascript]
function hasNegativeCycle(edges, n) {
    const dist = new Array(n).fill(0);  // Start with 0 for all
    
    for (let i = 0; i < n; i++) {
        for (const [u, v, weight] of edges) {
            if (dist[u] + weight < dist[v]) {
                if (i === n - 1) return true;  // Nth iteration has update
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    return false;
}

[python]
def has_negative_cycle(edges, n):
    dist = [0] * n  # Start with 0 for all
    
    for i in range(n):
        for u, v, weight in edges:
            if dist[u] + weight < dist[v]:
                if i == n - 1:
                    return True  # Nth iteration has update
                dist[v] = dist[u] + weight
    
    return False

[java]
public boolean hasNegativeCycle(int[][] edges, int n) {
    int[] dist = new int[n];  // Start with 0 for all
    
    for (int i = 0; i < n; i++) {
        for (int[] edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (dist[u] + weight < dist[v]) {
                if (i == n - 1) return true;  // Nth iteration has update
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    return false;
}

[cpp]
bool hasNegativeCycle(std::vector<std::vector<int>>& edges, int n) {
    std::vector<int> dist(n, 0);  // Start with 0 for all
    
    for (int i = 0; i < n; i++) {
        for (auto& edge : edges) {
            int u = edge[0], v = edge[1], weight = edge[2];
            if (dist[u] + weight < dist[v]) {
                if (i == n - 1) return true;  // Nth iteration has update
                dist[v] = dist[u] + weight;
            }
        }
    }
    
    return false;
}
```

## Applications

| Application | Description |
|-------------|-------------|
| **Currency Arbitrage** | Detect profit opportunities in exchange rates |
| **Network Routing** | RIP protocol uses Bellman-Ford variant |
| **Negative Weights** | Any graph with potential negative edges |
| **Cycle Detection** | Find negative cycles in directed graphs |

## Key Takeaways

1. **Handles negative weights** - unlike Dijkstra
2. **Detects negative cycles** - returns null/false if cycle exists
3. **O(V × E) time** - slower than Dijkstra but more versatile
4. **V-1 iterations** - maximum path length in acyclic graph
5. **Nth iteration check** - if values still change, negative cycle exists
