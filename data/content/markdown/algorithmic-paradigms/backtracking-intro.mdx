# Backtracking

Backtracking is a recursive algorithm technique that tries to build a solution incrementally, abandoning paths that don't lead to a valid solution.

## How It Works

```
Decision Tree for [1,2,3] Subsets:
                    []
           /        |        \
         [1]       [2]       [3]
        /   \       |
     [1,2] [1,3]  [2,3]
       |
    [1,2,3]

Each path = one valid subset
Backtracking explores all paths systematically
```

## The Pattern

1. **Choose:** Make a choice
2. **Explore:** Recursively explore further
3. **Unchoose:** If it doesn't work, undo the choice and try another

## Template

```multi
[javascript]
function backtrack(state, result) {
    if (isSolution(state)) {
        result.push([...state]);  // Found a solution
        return;
    }
    
    for (const choice of getChoices(state)) {
        if (isValid(choice)) {
            makeChoice(state, choice);
            backtrack(state, result);
            undoChoice(state, choice);  // Backtrack
        }
    }
}

[python]
def backtrack(state, result):
    if is_solution(state):
        result.append(state[:])  # Found a solution
        return
    
    for choice in get_choices(state):
        if is_valid(choice):
            make_choice(state, choice)
            backtrack(state, result)
            undo_choice(state, choice)  # Backtrack

[java]
void backtrack(List<Integer> state, List<List<Integer>> result) {
    if (isSolution(state)) {
        result.add(new ArrayList<>(state));  // Found a solution
        return;
    }
    
    for (int choice : getChoices(state)) {
        if (isValid(choice)) {
            makeChoice(state, choice);
            backtrack(state, result);
            undoChoice(state, choice);  // Backtrack
        }
    }
}

[cpp]
void backtrack(vector<int>& state, vector<vector<int>>& result) {
    if (isSolution(state)) {
        result.push_back(state);  // Found a solution
        return;
    }
    
    for (int choice : getChoices(state)) {
        if (isValid(choice)) {
            makeChoice(state, choice);
            backtrack(state, result);
            undoChoice(state, choice);  // Backtrack
        }
    }
}
```

## Classic Problems

### Subsets

Generate all subsets of a set.

```multi
[javascript]
function subsets(nums) {
    const result = [];
    
    function backtrack(start, path) {
        result.push([...path]);
        
        for (let i = start; i < nums.length; i++) {
            path.push(nums[i]);
            backtrack(i + 1, path);
            path.pop();  // Backtrack
        }
    }
    
    backtrack(0, []);
    return result;
}

// Usage
console.log(subsets([1, 2, 3]));
// [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]

[python]
def subsets(nums):
    """
    Generate all 2^n subsets.
    Time: O(n * 2^n), Space: O(n)
    """
    result = []
    
    def backtrack(start, path):
        result.append(path[:])
        
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()  # Backtrack
    
    backtrack(0, [])
    return result

# Usage
print(subsets([1, 2, 3]))
# [[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]

[java]
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(nums, 0, new ArrayList<>(), result);
    return result;
}

private void backtrack(int[] nums, int start, 
                       List<Integer> path, List<List<Integer>> result) {
    result.add(new ArrayList<>(path));
    
    for (int i = start; i < nums.length; i++) {
        path.add(nums[i]);
        backtrack(nums, i + 1, path, result);
        path.remove(path.size() - 1);  // Backtrack
    }
}

[cpp]
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> path;
        backtrack(nums, 0, path, result);
        return result;
    }
    
    void backtrack(vector<int>& nums, int start,
                   vector<int>& path, vector<vector<int>>& result) {
        result.push_back(path);
        
        for (int i = start; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtrack(nums, i + 1, path, result);
            path.pop_back();  // Backtrack
        }
    }
};
```

### Permutations

Generate all permutations of a set.

```multi
[javascript]
function permutations(nums) {
    const result = [];
    const used = new Array(nums.length).fill(false);
    
    function backtrack(path) {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            
            path.push(nums[i]);
            used[i] = true;
            backtrack(path);
            path.pop();
            used[i] = false;
        }
    }
    
    backtrack([]);
    return result;
}

[python]
def permutations(nums):
    """
    Generate all n! permutations.
    Time: O(n * n!), Space: O(n)
    """
    result = []
    
    def backtrack(path, used):
        if len(path) == len(nums):
            result.append(path[:])
            return
        
        for i in range(len(nums)):
            if used[i]:
                continue
            
            path.append(nums[i])
            used[i] = True
            backtrack(path, used)
            path.pop()
            used[i] = False
    
    backtrack([], [False] * len(nums))
    return result

[java]
public List<List<Integer>> permutations(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    boolean[] used = new boolean[nums.length];
    backtrack(nums, new ArrayList<>(), used, result);
    return result;
}

private void backtrack(int[] nums, List<Integer> path,
                       boolean[] used, List<List<Integer>> result) {
    if (path.size() == nums.length) {
        result.add(new ArrayList<>(path));
        return;
    }
    
    for (int i = 0; i < nums.length; i++) {
        if (used[i]) continue;
        
        path.add(nums[i]);
        used[i] = true;
        backtrack(nums, path, used, result);
        path.remove(path.size() - 1);
        used[i] = false;
    }
}

[cpp]
class Solution {
public:
    vector<vector<int>> permutations(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> path;
        vector<bool> used(nums.size(), false);
        backtrack(nums, path, used, result);
        return result;
    }
    
    void backtrack(vector<int>& nums, vector<int>& path,
                   vector<bool>& used, vector<vector<int>>& result) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        
        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) continue;
            
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums, path, used, result);
            path.pop_back();
            used[i] = false;
        }
    }
};
```

### N-Queens

Place N queens on NxN board so no two threaten each other.

```multi
[javascript]
function solveNQueens(n) {
    const result = [];
    const board = Array.from({ length: n }, () => 
        Array(n).fill('.'));
    
    function isValid(row, col) {
        // Check column
        for (let i = 0; i < row; i++) {
            if (board[i][col] === 'Q') return false;
        }
        
        // Check diagonals
        for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] === 'Q') return false;
        }
        for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (board[i][j] === 'Q') return false;
        }
        
        return true;
    }
    
    function backtrack(row) {
        if (row === n) {
            result.push(board.map(r => r.join('')));
            return;
        }
        
        for (let col = 0; col < n; col++) {
            if (isValid(row, col)) {
                board[row][col] = 'Q';
                backtrack(row + 1);
                board[row][col] = '.';
            }
        }
    }
    
    backtrack(0);
    return result;
}

[python]
def solve_n_queens(n):
    """
    Time: O(n!), Space: O(n^2)
    """
    result = []
    
    def backtrack(row, cols, diag1, diag2, board):
        if row == n:
            result.append([''.join(r) for r in board])
            return
        
        for col in range(n):
            d1, d2 = row - col, row + col
            if col in cols or d1 in diag1 or d2 in diag2:
                continue
            
            board[row][col] = 'Q'
            cols.add(col)
            diag1.add(d1)
            diag2.add(d2)
            
            backtrack(row + 1, cols, diag1, diag2, board)
            
            board[row][col] = '.'
            cols.remove(col)
            diag1.remove(d1)
            diag2.remove(d2)
    
    board = [['.' for _ in range(n)] for _ in range(n)]
    backtrack(0, set(), set(), set(), board)
    return result

[java]
public List<List<String>> solveNQueens(int n) {
    List<List<String>> result = new ArrayList<>();
    char[][] board = new char[n][n];
    for (char[] row : board) Arrays.fill(row, '.');
    
    Set<Integer> cols = new HashSet<>();
    Set<Integer> diag1 = new HashSet<>();
    Set<Integer> diag2 = new HashSet<>();
    
    backtrack(0, n, board, cols, diag1, diag2, result);
    return result;
}

private void backtrack(int row, int n, char[][] board,
                       Set<Integer> cols, Set<Integer> diag1,
                       Set<Integer> diag2, List<List<String>> result) {
    if (row == n) {
        List<String> solution = new ArrayList<>();
        for (char[] r : board) solution.add(new String(r));
        result.add(solution);
        return;
    }
    
    for (int col = 0; col < n; col++) {
        int d1 = row - col, d2 = row + col;
        if (cols.contains(col) || diag1.contains(d1) || diag2.contains(d2))
            continue;
        
        board[row][col] = 'Q';
        cols.add(col);
        diag1.add(d1);
        diag2.add(d2);
        
        backtrack(row + 1, n, board, cols, diag1, diag2, result);
        
        board[row][col] = '.';
        cols.remove(col);
        diag1.remove(d1);
        diag2.remove(d2);
    }
}

[cpp]
class Solution {
public:
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> result;
        vector<string> board(n, string(n, '.'));
        unordered_set<int> cols, diag1, diag2;
        backtrack(0, n, board, cols, diag1, diag2, result);
        return result;
    }
    
    void backtrack(int row, int n, vector<string>& board,
                   unordered_set<int>& cols, unordered_set<int>& diag1,
                   unordered_set<int>& diag2, vector<vector<string>>& result) {
        if (row == n) {
            result.push_back(board);
            return;
        }
        
        for (int col = 0; col < n; col++) {
            int d1 = row - col, d2 = row + col;
            if (cols.count(col) || diag1.count(d1) || diag2.count(d2))
                continue;
            
            board[row][col] = 'Q';
            cols.insert(col);
            diag1.insert(d1);
            diag2.insert(d2);
            
            backtrack(row + 1, n, board, cols, diag1, diag2, result);
            
            board[row][col] = '.';
            cols.erase(col);
            diag1.erase(d1);
            diag2.erase(d2);
        }
    }
};
```

### Combination Sum

Find combinations that sum to target.

```multi
[javascript]
function combinationSum(candidates, target) {
    const result = [];
    
    function backtrack(start, remaining, path) {
        if (remaining === 0) {
            result.push([...path]);
            return;
        }
        if (remaining < 0) return;
        
        for (let i = start; i < candidates.length; i++) {
            path.push(candidates[i]);
            backtrack(i, remaining - candidates[i], path);  // Can reuse
            path.pop();
        }
    }
    
    backtrack(0, target, []);
    return result;
}

[python]
def combination_sum(candidates, target):
    """
    Find all combinations summing to target.
    Each number can be used unlimited times.
    """
    result = []
    
    def backtrack(start, remaining, path):
        if remaining == 0:
            result.append(path[:])
            return
        if remaining < 0:
            return
        
        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(i, remaining - candidates[i], path)  # Can reuse
            path.pop()
    
    backtrack(0, target, [])
    return result

[java]
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(candidates, 0, target, new ArrayList<>(), result);
    return result;
}

private void backtrack(int[] candidates, int start, int remaining,
                       List<Integer> path, List<List<Integer>> result) {
    if (remaining == 0) {
        result.add(new ArrayList<>(path));
        return;
    }
    if (remaining < 0) return;
    
    for (int i = start; i < candidates.length; i++) {
        path.add(candidates[i]);
        backtrack(candidates, i, remaining - candidates[i], path, result);
        path.remove(path.size() - 1);
    }
}

[cpp]
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> result;
        vector<int> path;
        backtrack(candidates, 0, target, path, result);
        return result;
    }
    
    void backtrack(vector<int>& candidates, int start, int remaining,
                   vector<int>& path, vector<vector<int>>& result) {
        if (remaining == 0) {
            result.push_back(path);
            return;
        }
        if (remaining < 0) return;
        
        for (int i = start; i < candidates.size(); i++) {
            path.push_back(candidates[i]);
            backtrack(candidates, i, remaining - candidates[i], path, result);
            path.pop_back();
        }
    }
};
```

## Time Complexity

Usually exponential: O(k^n) or O(n!)

| Problem | Time Complexity |
|---------|-----------------|
| Subsets | O(n × 2^n) |
| Permutations | O(n × n!) |
| N-Queens | O(n!) |
| Combination Sum | O(2^n) |

## Pruning Techniques

1. **Early termination**: Stop if partial solution can't lead to valid solution
2. **Ordering**: Sort candidates to enable better pruning
3. **Constraint tracking**: Use sets/bitmasks for O(1) validity checks

## Key Takeaways

1. **Choose → Explore → Unchoose** is the core pattern
2. **All backtracking is DFS** on a decision tree
3. **Pruning** reduces search space dramatically
4. **Time is exponential** but often acceptable for small inputs
5. **Common patterns**: subsets, permutations, combinations, constraint satisfaction
