# Longest Common Subsequence (LCS)

**LCS** finds the longest subsequence common to two sequences. A **subsequence** maintains relative order but doesn't need to be contiguous.

## Visual Example

```
X: "ABCDGH"
Y: "AEDFHR"

Subsequences of X: A, AB, ACD, ABCDGH, ACH, ...
Common with Y:     A, AD, ADH, ...

LCS: "ADH" (length 3)

Alignment:
X: A B C D G H
      ↓   ↓   ↓
Y: A E D F H R
   ↑   ↑   ↑
   A   D   H ← LCS
```

---

## Algorithm Intuition

For each character pair (X[i], Y[j]):
- If they **match**: LCS includes this character
- If they **don't match**: Try skipping from X or Y, take the better result

```
Recurrence:
if X[i-1] == Y[j-1]:
    dp[i][j] = dp[i-1][j-1] + 1
else:
    dp[i][j] = max(dp[i-1][j], dp[i][j-1])
```

---

## Implementation

```multi
[javascript]
function lcs(X, Y) {
    /**
     * Longest Common Subsequence
     * Time: O(m × n), Space: O(m × n)
     */
    const m = X.length, n = Y.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i - 1] === Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// Usage
console.log(lcs("ABCDGH", "AEDFHR"));  // 3 (ADH)

[python]
def lcs(X, Y):
    """
    Longest Common Subsequence
    Time: O(m × n), Space: O(m × n)
    """
    m, n = len(X), len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    return dp[m][n]

# Usage
print(lcs("ABCDGH", "AEDFHR"))  # 3 (ADH)

[java]
public int lcs(String X, String Y) {
    /**
     * Longest Common Subsequence
     * Time: O(m × n), Space: O(m × n)
     */
    int m = X.length(), n = Y.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

[cpp]
int lcs(string X, string Y) {
    /**
     * Longest Common Subsequence
     * Time: O(m × n), Space: O(m × n)
     */
    int m = X.length(), n = Y.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}
```

---

## Reconstructing the LCS

```multi
[javascript]
function lcsWithString(X, Y) {
    const m = X.length, n = Y.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    
    // Fill DP table
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i - 1] === Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // Backtrack to find the LCS
    const lcs = [];
    let i = m, j = n;
    while (i > 0 && j > 0) {
        if (X[i - 1] === Y[j - 1]) {
            lcs.push(X[i - 1]);
            i--; j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return { length: dp[m][n], string: lcs.reverse().join('') };
}

[python]
def lcs_with_string(X, Y):
    """
    Returns both length and the actual LCS string.
    """
    m, n = len(X), len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # Fill DP table
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # Backtrack to find the LCS
    lcs = []
    i, j = m, n
    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            lcs.append(X[i - 1])
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1
    
    return dp[m][n], ''.join(reversed(lcs))

# Usage
length, lcs_str = lcs_with_string("ABCDGH", "AEDFHR")
print(f"Length: {length}, LCS: {lcs_str}")  # Length: 3, LCS: ADH

[java]
public String lcsWithString(String X, String Y) {
    int m = X.length(), n = Y.length();
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // Backtrack
    StringBuilder lcs = new StringBuilder();
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (X.charAt(i - 1) == Y.charAt(j - 1)) {
            lcs.append(X.charAt(i - 1));
            i--; j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    return lcs.reverse().toString();
}

[cpp]
pair<int, string> lcsWithString(string X, string Y) {
    int m = X.length(), n = Y.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    // Backtrack
    string lcs;
    int i = m, j = n;
    while (i > 0 && j > 0) {
        if (X[i - 1] == Y[j - 1]) {
            lcs += X[i - 1];
            i--; j--;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            i--;
        } else {
            j--;
        }
    }
    
    reverse(lcs.begin(), lcs.end());
    return {dp[m][n], lcs};
}
```

---

## Space-Optimized

```multi
[javascript]
function lcsOptimized(X, Y) {
    /**
     * Space-optimized LCS
     * Time: O(m × n), Space: O(min(m, n))
     */
    if (X.length < Y.length) [X, Y] = [Y, X];
    
    const m = X.length, n = Y.length;
    let prev = new Array(n + 1).fill(0);
    let curr = new Array(n + 1).fill(0);
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i - 1] === Y[j - 1]) {
                curr[j] = prev[j - 1] + 1;
            } else {
                curr[j] = Math.max(prev[j], curr[j - 1]);
            }
        }
        [prev, curr] = [curr, new Array(n + 1).fill(0)];
    }
    
    return prev[n];
}

[python]
def lcs_optimized(X, Y):
    """
    Time: O(m × n), Space: O(min(m, n))
    Only keep two rows at a time.
    """
    if len(X) < len(Y):
        X, Y = Y, X
    
    m, n = len(X), len(Y)
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                curr[j] = prev[j - 1] + 1
            else:
                curr[j] = max(prev[j], curr[j - 1])
        prev, curr = curr, [0] * (n + 1)
    
    return prev[n]

[java]
public int lcsOptimized(String X, String Y) {
    if (X.length() < Y.length()) {
        String temp = X; X = Y; Y = temp;
    }
    
    int m = X.length(), n = Y.length();
    int[] prev = new int[n + 1];
    int[] curr = new int[n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                curr[j] = prev[j - 1] + 1;
            } else {
                curr[j] = Math.max(prev[j], curr[j - 1]);
            }
        }
        int[] temp = prev;
        prev = curr;
        curr = temp;
        Arrays.fill(curr, 0);
    }
    
    return prev[n];
}

[cpp]
int lcsOptimized(string X, string Y) {
    if (X.length() < Y.length()) swap(X, Y);
    
    int m = X.length(), n = Y.length();
    vector<int> prev(n + 1, 0);
    vector<int> curr(n + 1, 0);
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X[i - 1] == Y[j - 1]) {
                curr[j] = prev[j - 1] + 1;
            } else {
                curr[j] = max(prev[j], curr[j - 1]);
            }
        }
        swap(prev, curr);
        fill(curr.begin(), curr.end(), 0);
    }
    
    return prev[n];
}
```

---

## Related Problems

### Longest Common Substring

**Contiguous** characters (not just same order).

```multi
[javascript]
function longestCommonSubstring(X, Y) {
    const m = X.length, n = Y.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    let maxLen = 0, endPos = 0;
    
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (X[i - 1] === Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    endPos = i;
                }
            }
            // No else: stays 0 (reset on mismatch)
        }
    }
    
    return X.slice(endPos - maxLen, endPos);
}

[python]
def longest_common_substring(X, Y):
    """
    Substring must be contiguous.
    Reset to 0 on mismatch.
    """
    m, n = len(X), len(Y)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    max_len = 0
    end_pos = 0
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
                if dp[i][j] > max_len:
                    max_len = dp[i][j]
                    end_pos = i
            # No else: stays 0 (reset on mismatch)
    
    return X[end_pos - max_len:end_pos]

[java]
public String longestCommonSubstring(String X, String Y) {
    int m = X.length(), n = Y.length();
    int[][] dp = new int[m + 1][n + 1];
    int maxLen = 0, endPos = 0;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X.charAt(i - 1) == Y.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    endPos = i;
                }
            }
        }
    }
    
    return X.substring(endPos - maxLen, endPos);
}

[cpp]
string longestCommonSubstring(string X, string Y) {
    int m = X.length(), n = Y.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    int maxLen = 0, endPos = 0;
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X[i - 1] == Y[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    endPos = i;
                }
            }
        }
    }
    
    return X.substr(endPos - maxLen, maxLen);
}
```

### Longest Palindromic Subsequence

LCS of string with its reverse.

```multi
[javascript]
function longestPalindromeSubseq(s) {
    return lcs(s, s.split('').reverse().join(''));
}

[python]
def longest_palindrome_subseq(s):
    """LCS(s, reverse(s))"""
    return lcs(s, s[::-1])

[java]
public int longestPalindromeSubseq(String s) {
    return lcs(s, new StringBuilder(s).reverse().toString());
}

[cpp]
int longestPalindromeSubseq(string s) {
    string rev = s;
    reverse(rev.begin(), rev.end());
    return lcs(s, rev);
}
```

---

## LCS vs LCSubstring

| Aspect | LCS (Subsequence) | LC Substring |
|--------|-------------------|--------------|
| Contiguous | No | Yes |
| On mismatch | max(skip X, skip Y) | Reset to 0 |
| Recurrence | `dp[i-1][j-1] + 1` or `max(...)` | `dp[i-1][j-1] + 1` or `0` |
| Track result | `dp[m][n]` | `max(all cells)` |

---

## Time & Space Complexity

| Algorithm | Time | Space |
|-----------|------|-------|
| Recursive | O(2^(m+n)) | O(m + n) |
| Memoization | O(m × n) | O(m × n) |
| Tabulation | O(m × n) | O(m × n) |
| Optimized | O(m × n) | O(min(m, n)) |

---

## Key Takeaways

1. **LCS is fundamental** to many string DP problems
2. **Recurrence pattern**: match → diagonal + 1, else max(left, top)
3. **Backtrack** to reconstruct the actual string
4. **Space optimization** possible with rolling arrays
5. **Common variations**: Edit distance, SCS, Palindrome problems
