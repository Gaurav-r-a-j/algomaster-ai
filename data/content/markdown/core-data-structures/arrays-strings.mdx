# Arrays & Strings

Arrays and strings are the **most fundamental data structures** in programming. Mastering them is essential for solving most coding problems.

## Visual Representation

```
Array: [10, 20, 30, 40, 50]
        ↑    ↑    ↑    ↑    ↑
Index:  0    1    2    3    4

Memory: Contiguous block
┌────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │
└────┴────┴────┴────┴────┘
 0x00 0x04 0x08 0x0C 0x10  ← Memory addresses
```

---

## Arrays

### Core Operations

| Operation | Time Complexity | Description |
|-----------|-----------------|-------------|
| Access by index | O(1) | Direct memory calculation |
| Search (unsorted) | O(n) | Check each element |
| Search (sorted) | O(log n) | Binary search |
| Insert at end | O(1) | Amortized for dynamic arrays |
| Insert at middle | O(n) | Shift elements |
| Delete at middle | O(n) | Shift elements |

### Array Basics

```multi
[java]script
// Creating arrays
const arr = [1, 2, 3, 4, 5];
const zeros = new Array(10).fill(0);
const matrix = Array.from({ length: 3 }, () => new Array(3).fill(0));

// Access (O(1))
const first = arr[0];
const last = arr[arr.length - 1];

// Modification
arr.push(6);           // Add to end - O(1)
arr.unshift(0);        // Add to front - O(n)
arr.pop();             // Remove last - O(1)
arr.shift();           // Remove first - O(n)
arr.splice(2, 1);      // Remove at index 2 - O(n)

// Searching
const idx = arr.indexOf(4);     // Get index
const exists = arr.includes(4); // Check existence
const found = arr.find(x => x > 3);  // Find first match

// Transformations (functional)
const doubled = arr.map(x => x * 2);
const evens = arr.filter(x => x % 2 === 0);
const sum = arr.reduce((acc, x) => acc + x, 0);

// Sorting
arr.sort((a, b) => a - b);  // Numeric sort
[python]
# Creating arrays
arr = [1, 2, 3, 4, 5]
arr = [0] * 10  # [0, 0, 0, ..., 0]
matrix = [[0] * 3 for _ in range(3)]  # 3x3 matrix

# Access (O(1))
first = arr[0]
last = arr[-1]
second_last = arr[-2]

# Slicing (O(k) where k is slice size)
sub = arr[1:4]      # [2, 3, 4]
reversed = arr[::-1]  # [5, 4, 3, 2, 1]
copy = arr[:]       # Shallow copy

# Modification
arr.append(6)       # Add to end - O(1) amortized
arr.insert(2, 10)   # Insert at index 2 - O(n)
arr.pop()           # Remove last - O(1)
arr.pop(0)          # Remove first - O(n)
arr.remove(3)       # Remove first occurrence - O(n)

# Searching
idx = arr.index(4)  # Get index - O(n)
exists = 4 in arr   # Check existence - O(n)

# Sorting
arr.sort()          # In-place sort - O(n log n)
sorted_arr = sorted(arr)  # Returns new list

# Useful functions
length = len(arr)
minimum = min(arr)
maximum = max(arr)
total = sum(arr)
[java]
// Static array
int[] arr = {1, 2, 3, 4, 5};
int[] zeros = new int[10];  // Initialized to 0
int[][] matrix = new int[3][3];  // 3x3 matrix

// Access (O(1))
int first = arr[0];
int last = arr[arr.length - 1];

// Dynamic array (ArrayList)
ArrayList<Integer> list = new ArrayList<>();
list.add(1);              // Add to end - O(1)
list.add(0, 10);          // Insert at index - O(n)
list.get(0);              // Access - O(1)
list.remove(0);           // Remove at index - O(n)
list.size();              // Get length

// Searching
int idx = list.indexOf(4);     // Get index
boolean exists = list.contains(4);  // Check existence

// Sorting
Arrays.sort(arr);              // Sort array
Collections.sort(list);        // Sort ArrayList
Arrays.binarySearch(arr, 3);   // Binary search

// Useful methods
int length = arr.length;
int max = Arrays.stream(arr).max().getAsInt();
int sum = Arrays.stream(arr).sum();
[cpp]
// Static array
int arr[] = {1, 2, 3, 4, 5};
int zeros[10] = {0};  // Initialized to 0

// Dynamic array (vector)
vector<int> vec = {1, 2, 3, 4, 5};
vector<int> zeros(10, 0);  // 10 zeros
vector<vector<int>> matrix(3, vector<int>(3, 0));  // 3x3

// Access (O(1))
int first = vec[0];
int last = vec.back();
int second = vec.at(1);  // With bounds checking

// Modification
vec.push_back(6);        // Add to end - O(1)
vec.insert(vec.begin() + 2, 10);  // Insert at index - O(n)
vec.pop_back();          // Remove last - O(1)
vec.erase(vec.begin());  // Remove first - O(n)

// Searching
auto it = find(vec.begin(), vec.end(), 4);
bool exists = it != vec.end();
int idx = distance(vec.begin(), it);

// Sorting
sort(vec.begin(), vec.end());  // Ascending
sort(vec.begin(), vec.end(), greater<int>());  // Descending

// Useful functions
int size = vec.size();
int maxVal = *max_element(vec.begin(), vec.end());
int sum = accumulate(vec.begin(), vec.end(), 0);
```

---

## Strings

Strings are **immutable** in most languages (Python, Java, JavaScript). Every "modification" creates a new string.

### Core Operations

| Operation | Time Complexity |
|-----------|-----------------|
| Access character | O(1) |
| Concatenation | O(n + m) |
| Substring | O(k) where k is length |
| Search substring | O(n × m) naive |
| Compare | O(min(n, m)) |

### String Basics

```multi
[java]script
const s = "Hello, World!";

// Access
const first = s[0];       // 'H'
const last = s.at(-1);    // '!'

// Methods
s.toLowerCase();          // "hello, world!"
s.toUpperCase();          // "HELLO, WORLD!"
s.trim();                 // Remove whitespace
s.split(", ");            // ["Hello", "World!"]
["a", "b"].join(", ");    // "a, b"

// Searching
s.indexOf("World");       // 7
s.includes("World");      // true
s.startsWith("Hello");    // true
s.endsWith("!");          // true

// Substring
s.slice(0, 5);            // "Hello"
s.substring(0, 5);        // "Hello"

// Replace
s.replace("World", "JS"); // "Hello, JS!"
s.replaceAll("l", "L");   // "HeLLo, WorLd!"

// Template literals
const name = "Alice";
const greeting = `Hello, ${name}!`;  // "Hello, Alice!"
[python]
s = "Hello, World!"

# Access (O(1))
first = s[0]       # 'H'
last = s[-1]       # '!'

# Slicing
sub = s[0:5]       # "Hello"
rev = s[::-1]      # "!dlroW ,olleH"

# String methods
s.lower()          # "hello, world!"
s.upper()          # "HELLO, WORLD!"
s.strip()          # Remove whitespace
s.split(", ")      # ["Hello", "World!"]
", ".join(["a", "b"])  # "a, b"

# Searching
idx = s.find("World")     # 7 (or -1 if not found)
idx = s.index("World")    # 7 (raises error if not found)
count = s.count("l")      # 3
exists = "World" in s     # True

# Replace
new_s = s.replace("World", "Python")  # "Hello, Python!"

# Character checks
"abc".isalpha()    # True
"123".isdigit()    # True
"abc123".isalnum() # True

# Building strings efficiently
chars = []
for c in "hello":
    chars.append(c.upper())
result = "".join(chars)  # "HELLO"
[java]
String s = "Hello, World!";

// Access (O(1))
char first = s.charAt(0);      // 'H'
char last = s.charAt(s.length() - 1);  // '!'

// Methods
s.toLowerCase();               // "hello, world!"
s.toUpperCase();               // "HELLO, WORLD!"
s.trim();                      // Remove whitespace
s.split(", ");                 // ["Hello", "World!"]
String.join(", ", "a", "b");   // "a, b"

// Searching
int idx = s.indexOf("World");  // 7
boolean contains = s.contains("World");  // true
boolean starts = s.startsWith("Hello");  // true
boolean ends = s.endsWith("!");          // true

// Substring
String sub = s.substring(0, 5);  // "Hello"

// Replace
String newS = s.replace("World", "Java");  // "Hello, Java!"

// Character checks
Character.isLetter('a');    // true
Character.isDigit('1');     // true
Character.isAlphabetic('a'); // true

// StringBuilder for efficient concatenation
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" World");
String result = sb.toString();
[cpp]
string s = "Hello, World!";

// Access (O(1))
char first = s[0];         // 'H'
char last = s.back();      // '!'

// Methods
transform(s.begin(), s.end(), s.begin(), ::tolower);
transform(s.begin(), s.end(), s.begin(), ::toupper);

// Substring
string sub = s.substr(0, 5);  // "Hello"

// Searching
size_t idx = s.find("World");  // 7
bool found = idx != string::npos;
bool starts = s.rfind("Hello", 0) == 0;

// Replace
s.replace(s.find("World"), 5, "C++");  // "Hello, C++!"

// Character checks
isalpha('a');    // true
isdigit('1');    // true
isalnum('a');    // true

// String stream for building
stringstream ss;
ss << "Hello" << " " << "World";
string result = ss.str();

// Modern C++ string concatenation
string greeting = "Hello, " + string("World!");
```

---

## Common Patterns

### 1. Two Pointers

```multi
[java]script
// Reverse a string in-place
function reverseString(s) {
    const chars = s.split('');
    let left = 0, right = chars.length - 1;
    
    while (left < right) {
        [chars[left], chars[right]] = [chars[right], chars[left]];
        left++;
        right--;
    }
    
    return chars.join('');
}

// Check if palindrome
function isPalindrome(s) {
    let left = 0, right = s.length - 1;
    
    while (left < right) {
        if (s[left] !== s[right]) return false;
        left++;
        right--;
    }
    
    return true;
}
[python]
# Reverse a string in-place
def reverse_string(s):
    chars = list(s)
    left, right = 0, len(chars) - 1
    
    while left < right:
        chars[left], chars[right] = chars[right], chars[left]
        left += 1
        right -= 1
    
    return "".join(chars)

# Check if palindrome
def is_palindrome(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    
    return True
[java]
// Reverse a string in-place
public static String reverseString(String s) {
    char[] chars = s.toCharArray();
    int left = 0, right = chars.length - 1;
    
    while (left < right) {
        char temp = chars[left];
        chars[left] = chars[right];
        chars[right] = temp;
        left++;
        right--;
    }
    
    return new String(chars);
}

// Check if palindrome
public static boolean isPalindrome(String s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) return false;
        left++;
        right--;
    }
    
    return true;
}
[cpp]
// Reverse a string in-place
string reverseString(string s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
    
    return s;
}

// Check if palindrome
bool isPalindrome(string s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        if (s[left] != s[right]) return false;
        left++;
        right--;
    }
    
    return true;
}
```

### 2. Sliding Window

```multi
[java]script
// Maximum sum of k consecutive elements
function maxSumSubarray(arr, k) {
    if (arr.length < k) return null;
    
    // Calculate first window
    let windowSum = arr.slice(0, k).reduce((a, b) => a + b, 0);
    let maxSum = windowSum;
    
    // Slide the window
    for (let i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}

// Longest substring without repeating chars
function lengthOfLongestSubstring(s) {
    const charSet = new Set();
    let left = 0, maxLen = 0;
    
    for (let right = 0; right < s.length; right++) {
        while (charSet.has(s[right])) {
            charSet.delete(s[left]);
            left++;
        }
        charSet.add(s[right]);
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
[python]
# Maximum sum of k consecutive elements
def max_sum_subarray(arr, k):
    if len(arr) < k:
        return None
    
    # Calculate first window
    window_sum = sum(arr[:k])
    max_sum = window_sum
    
    # Slide the window
    for i in range(k, len(arr)):
        window_sum = window_sum - arr[i - k] + arr[i]
        max_sum = max(max_sum, window_sum)
    
    return max_sum

# Longest substring without repeating chars
def length_of_longest_substring(s):
    char_set = set()
    left = 0
    max_len = 0
    
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    
    return max_len
[java]
// Maximum sum of k consecutive elements
public static int maxSumSubarray(int[] arr, int k) {
    if (arr.length < k) return -1;
    
    // Calculate first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;
    
    // Slide the window
    for (int i = k; i < arr.length; i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = Math.max(maxSum, windowSum);
    }
    
    return maxSum;
}

// Longest substring without repeating chars
public static int lengthOfLongestSubstring(String s) {
    Set<Character> charSet = new HashSet<>();
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        while (charSet.contains(s.charAt(right))) {
            charSet.remove(s.charAt(left));
            left++;
        }
        charSet.add(s.charAt(right));
        maxLen = Math.max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
[cpp]
// Maximum sum of k consecutive elements
int maxSumSubarray(vector<int>& arr, int k) {
    if (arr.size() < k) return -1;
    
    // Calculate first window
    int windowSum = 0;
    for (int i = 0; i < k; i++) {
        windowSum += arr[i];
    }
    int maxSum = windowSum;
    
    // Slide the window
    for (int i = k; i < arr.size(); i++) {
        windowSum = windowSum - arr[i - k] + arr[i];
        maxSum = max(maxSum, windowSum);
    }
    
    return maxSum;
}

// Longest substring without repeating chars
int lengthOfLongestSubstring(string s) {
    unordered_set<char> charSet;
    int left = 0, maxLen = 0;
    
    for (int right = 0; right < s.length(); right++) {
        while (charSet.count(s[right])) {
            charSet.erase(s[left]);
            left++;
        }
        charSet.insert(s[right]);
        maxLen = max(maxLen, right - left + 1);
    }
    
    return maxLen;
}
```

### 3. Prefix Sum

```multi
[java]script
// Build prefix sum array
function buildPrefixSum(arr) {
    const prefix = [0];
    for (let i = 0; i < arr.length; i++) {
        prefix.push(prefix[i] + arr[i]);
    }
    return prefix;
}

// Get range sum O(1)
function rangeSum(prefix, left, right) {
    return prefix[right + 1] - prefix[left];
}

// Usage
const arr = [1, 2, 3, 4, 5];
const prefix = buildPrefixSum(arr);
console.log(rangeSum(prefix, 1, 3));  // 2 + 3 + 4 = 9
[python]
# Build prefix sum array
def build_prefix_sum(arr):
    prefix = [0] * (len(arr) + 1)
    for i in range(len(arr)):
        prefix[i + 1] = prefix[i] + arr[i]
    return prefix

# Get range sum O(1)
def range_sum(prefix, left, right):
    return prefix[right + 1] - prefix[left]

# Usage
arr = [1, 2, 3, 4, 5]
prefix = build_prefix_sum(arr)
print(range_sum(prefix, 1, 3))  # 2 + 3 + 4 = 9
[java]
// Build prefix sum array
public static int[] buildPrefixSum(int[] arr) {
    int[] prefix = new int[arr.length + 1];
    for (int i = 0; i < arr.length; i++) {
        prefix[i + 1] = prefix[i] + arr[i];
    }
    return prefix;
}

// Get range sum O(1)
public static int rangeSum(int[] prefix, int left, int right) {
    return prefix[right + 1] - prefix[left];
}

// Usage
int[] arr = {1, 2, 3, 4, 5};
int[] prefix = buildPrefixSum(arr);
System.out.println(rangeSum(prefix, 1, 3));  // 9
[cpp]
// Build prefix sum array
vector<int> buildPrefixSum(vector<int>& arr) {
    vector<int> prefix(arr.size() + 1, 0);
    for (int i = 0; i < arr.size(); i++) {
        prefix[i + 1] = prefix[i] + arr[i];
    }
    return prefix;
}

// Get range sum O(1)
int rangeSum(vector<int>& prefix, int left, int right) {
    return prefix[right + 1] - prefix[left];
}

// Usage
vector<int> arr = {1, 2, 3, 4, 5};
vector<int> prefix = buildPrefixSum(arr);
cout << rangeSum(prefix, 1, 3);  // 9
```

### 4. Hash Map for Counting

```multi
[java]script
// Count character frequencies
const counter = {};
for (const c of "aabbbcccc") {
    counter[c] = (counter[c] || 0) + 1;
}
// { a: 2, b: 3, c: 4 }

// Two Sum pattern
function twoSum(nums, target) {
    const seen = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (seen.has(complement)) {
            return [seen.get(complement), i];
        }
        seen.set(nums[i], i);
    }
    return [];
}
[python]
from collections import Counter

# Count character frequencies
s = "aabbbcccc"
counter = Counter(s)  # {'c': 4, 'b': 3, 'a': 2}

# Two Sum pattern
def two_sum(nums, target):
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
[java]
// Count character frequencies
Map<Character, Integer> counter = new HashMap<>();
for (char c : "aabbbcccc".toCharArray()) {
    counter.put(c, counter.getOrDefault(c, 0) + 1);
}
// {a=2, b=3, c=4}

// Two Sum pattern
public static int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> seen = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (seen.containsKey(complement)) {
            return new int[] {seen.get(complement), i};
        }
        seen.put(nums[i], i);
    }
    return new int[] {};
}
[cpp]
// Count character frequencies
unordered_map<char, int> counter;
for (char c : "aabbbcccc"s) {
    counter[c]++;
}
// {a: 2, b: 3, c: 4}

// Two Sum pattern
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> seen;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (seen.count(complement)) {
            return {seen[complement], i};
        }
        seen[nums[i]] = i;
    }
    return {};
}
```

---

## Classic Interview Problems

| Problem | Pattern | Time |
|---------|---------|------|
| Two Sum | Hash Map | O(n) |
| Valid Anagram | Counting | O(n) |
| Reverse String | Two Pointers | O(n) |
| Is Palindrome | Two Pointers | O(n) |
| Max Subarray | Kadane's | O(n) |
| Merge Sorted Arrays | Two Pointers | O(n + m) |
| Longest Substring No Repeat | Sliding Window | O(n) |
| Rotate Array | Reverse | O(n) |
| Product Except Self | Prefix/Suffix | O(n) |

---

## Key Takeaways

1. **Arrays** = Contiguous memory, O(1) access
2. **Strings** = Immutable in most languages
3. **Two Pointers** = Efficient for sorted/symmetric problems
4. **Sliding Window** = Subarray/substring problems
5. **Hash Map** = O(1) lookup for counting/pairing
6. **Prefix Sum** = O(1) range queries after O(n) preprocessing
