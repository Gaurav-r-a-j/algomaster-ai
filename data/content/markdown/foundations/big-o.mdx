# Big O Notation

**Big O notation** describes how an algorithm's performance (time or space) scales with input size. It's the universal language for discussing algorithm efficiency.

## Visual Overview

```
Performance
    ^
    |                         O(2^n) üí•
    |                    O(n¬≤) ‚ï±
    |               O(n log n)
    |          O(n) ‚ï±
    |     O(log n)
    | O(1) ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> Input Size (n)
```

---

## Real-World Analogies

| Complexity | Analogy | Example |
|------------|---------|---------|
| **O(1)** | Getting a drink from vending machine | Same time regardless of inventory |
| **O(log n)** | Looking up a word in dictionary | Skip half each time |
| **O(n)** | Reading a book | Must read each page |
| **O(n log n)** | Sorting a deck of cards efficiently | Merge sort style |
| **O(n¬≤)** | Everyone shakes hands with everyone | Grows quadratically |
| **O(2^n)** | Combinations of all outfits | Doubles with each item |

---

## Common Time Complexities

### O(1) - Constant Time ‚ö°

Same time regardless of input size.

```multi
[javascript]
function getFirst(arr) {
    return arr[0];  // Always instant
}

// Hash table lookup
const myDict = {"key": "value"};
const value = myDict["key"];  // O(1) average

// Array index access
const arr = [1, 2, 3, 4, 5];
const element = arr[3];  // O(1)

[python]
def get_first(arr):
    return arr[0]  # Always instant

# Hash table lookup
my_dict = {"key": "value"}
value = my_dict["key"]  # O(1) average

# Array index access
arr = [1, 2, 3, 4, 5]
element = arr[3]  # O(1)

[java]
public static int getFirst(int[] arr) {
    return arr[0];  // Always instant
}

// Hash table lookup
Map<String, String> myDict = new HashMap<>();
myDict.put("key", "value");
String value = myDict.get("key");  // O(1) average

// Array index access
int[] arr = {1, 2, 3, 4, 5};
int element = arr[3];  // O(1)

[cpp]
int getFirst(vector<int>& arr) {
    return arr[0];  // Always instant
}

// Hash table lookup
unordered_map<string, string> myDict;
myDict["key"] = "value";
string value = myDict["key"];  // O(1) average

// Array index access
vector<int> arr = {1, 2, 3, 4, 5};
int element = arr[3];  // O(1)
```

**Examples:** Array access, hash table lookup, stack push/pop

---

### O(log n) - Logarithmic Time üöÄ

Extremely efficient. Problem size halves each step.

```multi
[javascript]
function binarySearch(arr, target) {
    // Finds target in sorted array - O(log n)
    let left = 0;
    let right = arr.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

[python]
def binary_search(arr, target):
    """Finds target in sorted array - O(log n)"""
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

[java]
public static int binarySearch(int[] arr, int target) {
    // Finds target in sorted array - O(log n)
    int left = 0;
    int right = arr.length - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}

[cpp]
int binarySearch(vector<int>& arr, int target) {
    // Finds target in sorted array - O(log n)
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return -1;
}
```

**Examples:** Binary search, balanced BST operations

| n | log‚ÇÇ(n) |
|---|---------|
| 16 | 4 |
| 1,024 | 10 |
| 1,048,576 | 20 |
| 1 billion | 30 |

---

### O(n) - Linear Time üìà

Time grows proportionally with input.

```multi
[javascript]
function findMax(arr) {
    // Scans entire array - O(n)
    let maxVal = arr[0];
    for (const num of arr) {  // n iterations
        if (num > maxVal) {
            maxVal = num;
        }
    }
    return maxVal;
}

function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i;
        }
    }
    return -1;
}

[python]
def find_max(arr):
    """Scans entire array - O(n)"""
    max_val = arr[0]
    for num in arr:  # n iterations
        if num > max_val:
            max_val = num
    return max_val

def linear_search(arr, target):
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1

[java]
public static int findMax(int[] arr) {
    // Scans entire array - O(n)
    int maxVal = arr[0];
    for (int num : arr) {  // n iterations
        if (num > maxVal) {
            maxVal = num;
        }
    }
    return maxVal;
}

public static int linearSearch(int[] arr, int target) {
    for (int i = 0; i < arr.length; i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}

[cpp]
int findMax(vector<int>& arr) {
    // Scans entire array - O(n)
    int maxVal = arr[0];
    for (int num : arr) {  // n iterations
        if (num > maxVal) {
            maxVal = num;
        }
    }
    return maxVal;
}

int linearSearch(vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] == target) {
            return i;
        }
    }
    return -1;
}
```

**Examples:** Linear search, array sum, finding min/max

---

### O(n log n) - Linearithmic Time üìä

Optimal for comparison-based sorting.

```multi
[javascript]
function mergeSort(arr) {
    // Efficient sorting - O(n log n)
    if (arr.length <= 1) {
        return arr;
    }
    
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    
    return merge(left, right);
}

[python]
def merge_sort(arr):
    """Efficient sorting - O(n log n)"""
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

[java]
public static int[] mergeSort(int[] arr) {
    // Efficient sorting - O(n log n)
    if (arr.length <= 1) {
        return arr;
    }
    
    int mid = arr.length / 2;
    int[] left = mergeSort(Arrays.copyOfRange(arr, 0, mid));
    int[] right = mergeSort(Arrays.copyOfRange(arr, mid, arr.length));
    
    return merge(left, right);
}

[cpp]
vector<int> mergeSort(vector<int>& arr) {
    // Efficient sorting - O(n log n)
    if (arr.size() <= 1) {
        return arr;
    }
    
    int mid = arr.size() / 2;
    vector<int> left(arr.begin(), arr.begin() + mid);
    vector<int> right(arr.begin() + mid, arr.end());
    
    left = mergeSort(left);
    right = mergeSort(right);
    
    return merge(left, right);
}
```

**Examples:** Merge Sort, Quick Sort (average), Heap Sort

---

### O(n¬≤) - Quadratic Time üêå

Nested loops over input.

```multi
[javascript]
function bubbleSort(arr) {
    // Simple but slow sorting - O(n¬≤)
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

function hasDuplicatesNaive(arr) {
    // Check every pair - O(n¬≤)
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            if (arr[i] === arr[j]) {
                return true;
            }
        }
    }
    return false;
}

[python]
def bubble_sort(arr):
    """Simple but slow sorting - O(n¬≤)"""
    n = len(arr)
    for i in range(n):
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

def has_duplicates_naive(arr):
    """Check every pair - O(n¬≤)"""
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] == arr[j]:
                return True
    return False

[java]
public static void bubbleSort(int[] arr) {
    // Simple but slow sorting - O(n¬≤)
    int n = arr.length;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

public static boolean hasDuplicatesNaive(int[] arr) {
    // Check every pair - O(n¬≤)
    for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[i] == arr[j]) {
                return true;
            }
        }
    }
    return false;
}

[cpp]
void bubbleSort(vector<int>& arr) {
    // Simple but slow sorting - O(n¬≤)
    int n = arr.size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

bool hasDuplicatesNaive(vector<int>& arr) {
    // Check every pair - O(n¬≤)
    for (int i = 0; i < arr.size(); i++) {
        for (int j = i + 1; j < arr.size(); j++) {
            if (arr[i] == arr[j]) {
                return true;
            }
        }
    }
    return false;
}
```

**Examples:** Bubble Sort, Selection Sort, nested loops

---

### O(2^n) - Exponential Time üí•

Doubles with each input increase. Often optimizable with DP.

```multi
[javascript]
function fibonacciNaive(n) {
    // Without optimization - O(2^n)
    if (n <= 1) return n;
    return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);
}

function powerSet(s) {
    // All subsets - O(2^n)
    if (s.length === 0) return [[]];
    const rest = powerSet(s.slice(1));
    return rest.concat(rest.map(subset => [s[0], ...subset]));
}

[python]
def fibonacci_naive(n):
    """Without optimization - O(2^n)"""
    if n <= 1:
        return n
    return fibonacci_naive(n - 1) + fibonacci_naive(n - 2)

def power_set(s):
    """All subsets - O(2^n)"""
    if len(s) == 0:
        return [[]]
    rest = power_set(s[1:])
    return rest + [[s[0]] + subset for subset in rest]

[java]
public static int fibonacciNaive(int n) {
    // Without optimization - O(2^n)
    if (n <= 1) return n;
    return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);
}

public static List<List<Integer>> powerSet(List<Integer> s) {
    // All subsets - O(2^n)
    if (s.isEmpty()) {
        List<List<Integer>> result = new ArrayList<>();
        result.add(new ArrayList<>());
        return result;
    }
    List<List<Integer>> rest = powerSet(s.subList(1, s.size()));
    List<List<Integer>> result = new ArrayList<>(rest);
    for (List<Integer> subset : rest) {
        List<Integer> newSubset = new ArrayList<>();
        newSubset.add(s.get(0));
        newSubset.addAll(subset);
        result.add(newSubset);
    }
    return result;
}

[cpp]
int fibonacciNaive(int n) {
    // Without optimization - O(2^n)
    if (n <= 1) return n;
    return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);
}

vector<vector<int>> powerSet(vector<int>& s) {
    // All subsets - O(2^n)
    if (s.empty()) {
        return {{}};
    }
    vector<int> restVec(s.begin() + 1, s.end());
    vector<vector<int>> rest = powerSet(restVec);
    vector<vector<int>> result = rest;
    for (auto& subset : rest) {
        vector<int> newSubset = {s[0]};
        newSubset.insert(newSubset.end(), subset.begin(), subset.end());
        result.push_back(newSubset);
    }
    return result;
}
```

---

### O(n!) - Factorial Time üî•

Grows astronomically. Usually avoid!

```multi
[javascript]
function permutations(arr) {
    // All orderings - O(n!)
    if (arr.length <= 1) return [arr];
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        const rest = [...arr.slice(0, i), ...arr.slice(i + 1)];
        for (const perm of permutations(rest)) {
            result.push([arr[i], ...perm]);
        }
    }
    return result;
}

[python]
def permutations(arr):
    """All orderings - O(n!)"""
    if len(arr) <= 1:
        return [arr]
    result = []
    for i, num in enumerate(arr):
        rest = arr[:i] + arr[i+1:]
        for perm in permutations(rest):
            result.append([num] + perm)
    return result

[java]
public static List<List<Integer>> permutations(List<Integer> arr) {
    // All orderings - O(n!)
    if (arr.size() <= 1) {
        List<List<Integer>> result = new ArrayList<>();
        result.add(new ArrayList<>(arr));
        return result;
    }
    List<List<Integer>> result = new ArrayList<>();
    for (int i = 0; i < arr.size(); i++) {
        List<Integer> rest = new ArrayList<>(arr);
        rest.remove(i);
        for (List<Integer> perm : permutations(rest)) {
            List<Integer> newPerm = new ArrayList<>();
            newPerm.add(arr.get(i));
            newPerm.addAll(perm);
            result.add(newPerm);
        }
    }
    return result;
}

[cpp]
vector<vector<int>> permutations(vector<int> arr) {
    // All orderings - O(n!)
    if (arr.size() <= 1) {
        return {arr};
    }
    vector<vector<int>> result;
    for (int i = 0; i < arr.size(); i++) {
        vector<int> rest = arr;
        rest.erase(rest.begin() + i);
        for (auto& perm : permutations(rest)) {
            vector<int> newPerm = {arr[i]};
            newPerm.insert(newPerm.end(), perm.begin(), perm.end());
            result.push_back(newPerm);
        }
    }
    return result;
}
```

---

## Complexity Comparison Table

| Complexity | n=10 | n=100 | n=1,000 | n=10,000 |
|------------|------|-------|---------|----------|
| O(1) | 1 | 1 | 1 | 1 |
| O(log n) | 3 | 7 | 10 | 13 |
| O(n) | 10 | 100 | 1,000 | 10,000 |
| O(n log n) | 30 | 700 | 10,000 | 130,000 |
| O(n¬≤) | 100 | 10,000 | 1,000,000 | 100,000,000 |
| O(2^n) | 1,024 | 1.27√ó10¬≥‚Å∞ | ‚àû | ‚àû |

---

## Space Complexity

Memory used by algorithm (excluding input).

### O(1) Space - Constant

```multi
[javascript]
function sumArray(arr) {
    // Only uses one variable
    let total = 0;  // O(1) extra space
    for (const num of arr) {
        total += num;
    }
    return total;
}

function swap(arr, i, j) {
    // In-place swap
    [arr[i], arr[j]] = [arr[j], arr[i]];
}

[python]
def sum_array(arr):
    """Only uses one variable"""
    total = 0  # O(1) extra space
    for num in arr:
        total += num
    return total

def swap(arr, i, j):
    """In-place swap"""
    arr[i], arr[j] = arr[j], arr[i]

[java]
public static int sumArray(int[] arr) {
    // Only uses one variable
    int total = 0;  // O(1) extra space
    for (int num : arr) {
        total += num;
    }
    return total;
}

public static void swap(int[] arr, int i, int j) {
    // In-place swap
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

[cpp]
int sumArray(vector<int>& arr) {
    // Only uses one variable
    int total = 0;  // O(1) extra space
    for (int num : arr) {
        total += num;
    }
    return total;
}

void swap(vector<int>& arr, int i, int j) {
    // In-place swap
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

### O(n) Space - Linear

```multi
[javascript]
function reverseArray(arr) {
    // Creates copy of same size
    return [...arr].reverse();  // O(n) extra space
}

function fibonacciDP(n) {
    // Stores all values
    const dp = new Array(n + 1).fill(0);  // O(n) space
    dp[1] = 1;
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

[python]
def reverse_array(arr):
    """Creates copy of same size"""
    return arr[::-1]  # O(n) extra space

def fibonacci_dp(n):
    """Stores all values"""
    dp = [0] * (n + 1)  # O(n) space
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

[java]
public static int[] reverseArray(int[] arr) {
    // Creates copy of same size
    int[] reversed = new int[arr.length];  // O(n) extra space
    for (int i = 0; i < arr.length; i++) {
        reversed[i] = arr[arr.length - 1 - i];
    }
    return reversed;
}

public static int fibonacciDP(int n) {
    // Stores all values
    int[] dp = new int[n + 1];  // O(n) space
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

[cpp]
vector<int> reverseArray(vector<int>& arr) {
    // Creates copy of same size
    vector<int> reversed(arr.rbegin(), arr.rend());  // O(n) extra space
    return reversed;
}

int fibonacciDP(int n) {
    // Stores all values
    vector<int> dp(n + 1, 0);  // O(n) space
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

### O(log n) Space - Recursion Stack

```multi
[javascript]
function binarySearchRecursive(arr, target, left, right) {
    // Recursion depth is O(log n)
    if (left > right) {
        return -1;
    }
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

[python]
def binary_search_recursive(arr, target, left, right):
    """Recursion depth is O(log n)"""
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

[java]
public static int binarySearchRecursive(int[] arr, int target, int left, int right) {
    // Recursion depth is O(log n)
    if (left > right) {
        return -1;
    }
    int mid = (left + right) / 2;
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

[cpp]
int binarySearchRecursive(vector<int>& arr, int target, int left, int right) {
    // Recursion depth is O(log n)
    if (left > right) {
        return -1;
    }
    int mid = (left + right) / 2;
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}
```

---

## Time vs Space Tradeoff

| Approach | Time | Space | Example |
|----------|------|-------|---------|
| Brute Force | O(n¬≤) | O(1) | Two Sum with nested loops |
| Hash Table | O(n) | O(n) | Two Sum with hash map |
| Sort First | O(n log n) | O(1) | Two Sum with two pointers |

```multi
[javascript]
// Trade space for time
function twoSumFast(nums, target) {
    // O(n) time, O(n) space
    const seen = {};
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (complement in seen) {
            return [seen[complement], i];
        }
        seen[nums[i]] = i;
    }
    return [];
}

[python]
# Trade space for time
def two_sum_fast(nums, target):
    """O(n) time, O(n) space"""
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i

[java]
// Trade space for time
public static int[] twoSumFast(int[] nums, int target) {
    // O(n) time, O(n) space
    Map<Integer, Integer> seen = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (seen.containsKey(complement)) {
            return new int[]{seen.get(complement), i};
        }
        seen.put(nums[i], i);
    }
    return new int[]{};
}

[cpp]
// Trade space for time
vector<int> twoSumFast(vector<int>& nums, int target) {
    // O(n) time, O(n) space
    unordered_map<int, int> seen;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (seen.count(complement)) {
            return {seen[complement], i};
        }
        seen[nums[i]] = i;
    }
    return {};
}
```

---

## Rules for Analyzing Complexity

### 1. Drop Constants

```
O(2n) ‚Üí O(n)
O(100) ‚Üí O(1)
O(n/2) ‚Üí O(n)
```

### 2. Drop Lower-Order Terms

```
O(n¬≤ + n) ‚Üí O(n¬≤)
O(n¬≥ + n¬≤ + n) ‚Üí O(n¬≥)
O(n + log n) ‚Üí O(n)
```

### 3. Different Inputs = Different Variables

```multi
[javascript]
function printPairs(arr1, arr2) {
    for (const a of arr1) {      // O(a)
        for (const b of arr2) {  // O(b)
            console.log(a, b);
        }
    }
}
// Total: O(a √ó b), NOT O(n¬≤)

[python]
def print_pairs(arr1, arr2):
    for a in arr1:      # O(a)
        for b in arr2:  # O(b)
            print(a, b)
# Total: O(a √ó b), NOT O(n¬≤)

[java]
public static void printPairs(int[] arr1, int[] arr2) {
    for (int a : arr1) {      // O(a)
        for (int b : arr2) {  // O(b)
            System.out.println(a + " " + b);
        }
    }
}
// Total: O(a √ó b), NOT O(n¬≤)

[cpp]
void printPairs(vector<int>& arr1, vector<int>& arr2) {
    for (int a : arr1) {      // O(a)
        for (int b : arr2) {  // O(b)
            cout << a << " " << b << endl;
        }
    }
}
// Total: O(a √ó b), NOT O(n¬≤)
```

### 4. Nested Operations Multiply

```multi
[javascript]
for (let i = 0; i < n; i++) {        // O(n)
    for (let j = 0; j < m; j++) {    // O(m)
        // ...
    }
}
// Total: O(n √ó m)

[python]
for i in range(n):        # O(n)
    for j in range(m):    # O(m)
        # ...
# Total: O(n √ó m)

[java]
for (int i = 0; i < n; i++) {        // O(n)
    for (int j = 0; j < m; j++) {    // O(m)
        // ...
    }
}
// Total: O(n √ó m)

[cpp]
for (int i = 0; i < n; i++) {        // O(n)
    for (int j = 0; j < m; j++) {    // O(m)
        // ...
    }
}
// Total: O(n √ó m)
```

### 5. Sequential Operations Add

```multi
[javascript]
for (let i = 0; i < n; i++) {  // O(n)
    // ...
}

for (let j = 0; j < m; j++) {  // O(m)
    // ...
}
// Total: O(n + m)

[python]
for i in range(n):  # O(n)
    # ...

for j in range(m):  # O(m)
    # ...
# Total: O(n + m)

[java]
for (int i = 0; i < n; i++) {  // O(n)
    // ...
}

for (int j = 0; j < m; j++) {  // O(m)
    // ...
}
// Total: O(n + m)

[cpp]
for (int i = 0; i < n; i++) {  // O(n)
    // ...
}

for (int j = 0; j < m; j++) {  // O(m)
    // ...
}
// Total: O(n + m)
```

---

## Common Data Structure Operations

| Operation | Array | Linked List | Hash Table | BST (balanced) |
|-----------|-------|-------------|------------|----------------|
| Access | O(1) | O(n) | N/A | O(log n) |
| Search | O(n) | O(n) | O(1)* | O(log n) |
| Insert | O(n) | O(1) | O(1)* | O(log n) |
| Delete | O(n) | O(1) | O(1)* | O(log n) |

*Average case. Worst case is O(n) for hash tables.

---

## Algorithm Complexity Cheat Sheet

| Algorithm | Best | Average | Worst | Space |
|-----------|------|---------|-------|-------|
| **Searching** |
| Linear Search | O(1) | O(n) | O(n) | O(1) |
| Binary Search | O(1) | O(log n) | O(log n) | O(1) |
| **Sorting** |
| Bubble Sort | O(n) | O(n¬≤) | O(n¬≤) | O(1) |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) |
| Quick Sort | O(n log n) | O(n log n) | O(n¬≤) | O(log n) |
| Heap Sort | O(n log n) | O(n log n) | O(n log n) | O(1) |
| **Graphs** |
| BFS/DFS | O(V + E) | O(V + E) | O(V + E) | O(V) |
| Dijkstra | O((V+E) log V) | O((V+E) log V) | O((V+E) log V) | O(V) |

---

## Why Big O Matters

1. **Interviews**: Most companies test this directly
2. **Scalability**: Will your code work with 1M users?
3. **Optimization**: Know where to focus improvements
4. **System Design**: Choose appropriate algorithms
5. **Cost**: Faster algorithms = lower cloud bills

---

## Key Takeaways

1. Focus on **how growth scales**, not exact numbers
2. **Worst case** is what we typically analyze
3. **Drop constants and lower-order terms**
4. O(log n) is almost as good as O(1)
5. O(n log n) is optimal for comparison sorts
6. O(n¬≤) is often a sign to optimize
7. O(2^n) usually means look for DP solution
