# Loops

**Loops** allow you to execute code repeatedly, making them essential for processing data, implementing algorithms, and automating repetitive tasks.

## Visual Overview

```
for (i = 0; i < 3; i++)
    ┌─────────────┐
    │   i = 0     │
    │   Print(0)  │
    └──────┬──────┘
           ↓
    ┌─────────────┐
    │   i = 1     │
    │   Print(1)  │
    └──────┬──────┘
           ↓
    ┌─────────────┐
    │   i = 2     │
    │   Print(2)  │
    └──────┬──────┘
           ↓
        Done!
```

---

## Real-World Analogies

| Loop Type | Analogy | Example |
|-----------|---------|---------|
| **For Loop** | "Wash 10 plates" | You know exactly how many iterations |
| **While Loop** | "Wash until sink is empty" | Continue while condition is true |
| **Do-While** | "Try once, then check" | Execute at least once |
| **For-Each** | "Process each apple in basket" | Iterate over collection |

---

## Types of Loops

### For Loop

Best when you know the number of iterations.

```python
# Python - Basic for loop
for i in range(5):
    print(i)  # 0, 1, 2, 3, 4

# Iterate over collection
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# With index
for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")
```

```javascript
// JavaScript - Classic for loop
for (let i = 0; i < 5; i++) {
    console.log(i);  // 0, 1, 2, 3, 4
}

// For...of (iterate values)
for (const fruit of fruits) {
    console.log(fruit);
}

// For...in (iterate keys/indices)
for (const index in fruits) {
    console.log(`${index}: ${fruits[index]}`);
}
```

```java
// Java - Enhanced for loop
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}
```

---

### While Loop

Best when iterations depend on a condition.

```python
# Python
count = 0
while count < 5:
    print(count)
    count += 1

# Common pattern: Read until condition
while True:
    user_input = input("Enter 'quit' to exit: ")
    if user_input == 'quit':
        break
```

```javascript
// JavaScript
let count = 0;
while (count < 5) {
    console.log(count);
    count++;
}
```

---

### Do-While Loop

Executes at least once before checking condition.

```javascript
// JavaScript (Python doesn't have native do-while)
let count = 0;
do {
    console.log(count);
    count++;
} while (count < 5);
```

```python
# Python equivalent
count = 0
while True:
    print(count)
    count += 1
    if count >= 5:
        break
```

---

## Loop Comparison Table

| Feature | For | While | Do-While |
|---------|-----|-------|----------|
| **Iterations Known** | ✅ Yes | ❌ No | ❌ No |
| **Condition Check** | Before each | Before each | After each |
| **Min Executions** | 0 | 0 | 1 |
| **Best For** | Arrays, ranges | Unknown iterations | Menu systems |

---

## Loop Control Statements

### Break - Exit Immediately

```python
for i in range(10):
    if i == 5:
        break  # Exit loop when i is 5
    print(i)  # Prints 0, 1, 2, 3, 4
```

### Continue - Skip to Next Iteration

```python
for i in range(10):
    if i % 2 == 0:
        continue  # Skip even numbers
    print(i)  # Prints 1, 3, 5, 7, 9
```

### Pass - Do Nothing (Python)

```python
for i in range(5):
    if i == 3:
        pass  # Placeholder, does nothing
    print(i)  # Prints all: 0, 1, 2, 3, 4
```

---

## Common Loop Patterns

### Pattern 1: Accumulator

```python
# Sum all numbers
numbers = [1, 2, 3, 4, 5]
total = 0
for num in numbers:
    total += num
print(total)  # 15
```

### Pattern 2: Finding Max/Min

```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
max_val = numbers[0]
for num in numbers:
    if num > max_val:
        max_val = num
print(max_val)  # 9
```

### Pattern 3: Building a New Collection

```python
# Filter and transform
numbers = [1, 2, 3, 4, 5]
doubled_evens = []
for num in numbers:
    if num % 2 == 0:
        doubled_evens.append(num * 2)
print(doubled_evens)  # [4, 8]
```

### Pattern 4: Nested Loops (2D Traversal)

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for row in matrix:
    for element in row:
        print(element, end=' ')
    print()  # Newline after each row
```

### Pattern 5: Two Pointers

```python
# Find pair with target sum in sorted array
arr = [1, 2, 3, 4, 5, 6]
target = 7
left, right = 0, len(arr) - 1

while left < right:
    current_sum = arr[left] + arr[right]
    if current_sum == target:
        print(f"Found: {arr[left]} + {arr[right]}")
        break
    elif current_sum < target:
        left += 1
    else:
        right -= 1
```

### Pattern 6: Sliding Window

```python
# Maximum sum of k consecutive elements
arr = [1, 4, 2, 10, 2, 3, 1, 0, 20]
k = 3

# Initial window sum
window_sum = sum(arr[:k])
max_sum = window_sum

# Slide the window
for i in range(k, len(arr)):
    window_sum = window_sum - arr[i - k] + arr[i]
    max_sum = max(max_sum, window_sum)

print(max_sum)  # 23 (10 + 2 + 3 or 1 + 0 + 20)
```

---

## Time Complexity

| Pattern | Complexity | Example |
|---------|------------|---------|
| Single loop | O(n) | Iterate through array once |
| Nested loops (same size) | O(n²) | Compare all pairs |
| Nested loops (diff sizes) | O(n × m) | Matrix traversal |
| Binary search pattern | O(log n) | Halving each step |
| Two pointers | O(n) | Start from both ends |

---

## Avoiding Infinite Loops

```python
# DANGER - Infinite loop!
# while True:
#     print("Forever...")

# SAFE - Always have exit condition
count = 0
while count < 10:
    print(count)
    count += 1  # Don't forget to update!

# SAFE - Use break
while True:
    user_input = input("Type 'exit': ")
    if user_input == 'exit':
        break  # Exit condition
```

---

## Modern Loop Alternatives

### List Comprehension (Python)

```python
# Traditional loop
squares = []
for i in range(5):
    squares.append(i ** 2)

# List comprehension (one-liner)
squares = [i ** 2 for i in range(5)]  # [0, 1, 4, 9, 16]

# With condition
evens = [i for i in range(10) if i % 2 == 0]  # [0, 2, 4, 6, 8]
```

### Array Methods (JavaScript)

```javascript
const numbers = [1, 2, 3, 4, 5];

// map - transform each element
const doubled = numbers.map(n => n * 2);  // [2, 4, 6, 8, 10]

// filter - keep matching elements
const evens = numbers.filter(n => n % 2 === 0);  // [2, 4]

// reduce - accumulate to single value
const sum = numbers.reduce((acc, n) => acc + n, 0);  // 15

// forEach - side effects
numbers.forEach(n => console.log(n));
```

---

## Key Takeaways

1. **For loops** → Known iterations, iterating collections
2. **While loops** → Unknown iterations, condition-based
3. **Break** → Exit loop early
4. **Continue** → Skip current iteration
5. **Nested loops** → O(n²) complexity - use carefully
6. **Two pointers** → Efficient O(n) for sorted arrays
7. **List comprehensions** → Concise Python loops
8. **Array methods** → Functional JavaScript approach
