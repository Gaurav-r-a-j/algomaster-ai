# Quick Sort

**Quick Sort** is a highly efficient, divide-and-conquer sorting algorithm. It works by selecting a 'pivot' element and partitioning the array around it.

## Key Concept

1. **Choose a pivot** element
2. **Partition**: Move smaller elements left, larger elements right
3. **Recursively** sort the left and right partitions
4. **Combine**: Array is sorted!

## Visual Representation

```
Original: [8, 3, 7, 1, 5, 9, 2]
                   ↑
              pivot = 5

Partition:
[3, 1, 2] [5] [8, 7, 9]
  < 5      =    > 5

Recursively sort each partition...

Step 1: pivot = 5
        [3, 1, 2, 5, 8, 7, 9]
        └──┬──┘   └──┬──┘
          left     right

Step 2: Sort left [3, 1, 2], pivot = 2
        [1, 2, 3]

Step 3: Sort right [8, 7, 9], pivot = 9
        [7, 8, 9]

Result: [1, 2, 3, 5, 7, 8, 9]
```

---

## Implementation

```multi
[javascript]
// Simple version (not in-place)
function quickSort(arr) {
    if (arr.length <= 1) return arr;
    
    const pivot = arr[Math.floor(arr.length / 2)];
    const left = arr.filter(x => x < pivot);
    const middle = arr.filter(x => x === pivot);
    const right = arr.filter(x => x > pivot);
    
    return [...quickSort(left), ...middle, ...quickSort(right)];
}

// In-place version (Lomuto partition)
function quickSortInPlace(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pivotIdx = partition(arr, low, high);
        quickSortInPlace(arr, low, pivotIdx - 1);
        quickSortInPlace(arr, pivotIdx + 1, high);
    }
    return arr;
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    
    for (let j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// Usage
const arr = [8, 3, 7, 1, 5, 9, 2];
console.log(quickSort(arr));  // [1, 2, 3, 5, 7, 8, 9]

[python]
# Simple version (not in-place)
def quick_sort(arr):
    """
    Quick Sort using list comprehension (simple but not in-place).
    Time: O(n log n) average, O(n²) worst
    Space: O(n) due to new lists
    """
    if len(arr) <= 1:
        return arr
    
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    
    return quick_sort(left) + middle + quick_sort(right)

# In-place version (Lomuto partition)
def quick_sort_inplace(arr, low=0, high=None):
    """
    In-place Quick Sort using Lomuto partition scheme.
    Time: O(n log n) average, O(n²) worst
    Space: O(log n) for recursion stack
    """
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        pivot_idx = partition(arr, low, high)
        quick_sort_inplace(arr, low, pivot_idx - 1)
        quick_sort_inplace(arr, pivot_idx + 1, high)
    
    return arr

def partition(arr, low, high):
    """Lomuto partition: pivot is last element"""
    pivot = arr[high]
    i = low - 1  # Index of smaller element
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

# Usage
arr = [8, 3, 7, 1, 5, 9, 2]
print(quick_sort(arr))  # [1, 2, 3, 5, 7, 8, 9]

[java]
import java.util.Arrays;

public class QuickSort {
    
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIdx = partition(arr, low, high);
            quickSort(arr, low, pivotIdx - 1);
            quickSort(arr, pivotIdx + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {8, 3, 7, 1, 5, 9, 2};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
        // [1, 2, 3, 5, 7, 8, 9]
    }
}

[cpp]
#include <iostream>
#include <vector>
#include <algorithm>

int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pivotIdx = partition(arr, low, high);
        quickSort(arr, low, pivotIdx - 1);
        quickSort(arr, pivotIdx + 1, high);
    }
}

int main() {
    std::vector<int> arr = {8, 3, 7, 1, 5, 9, 2};
    quickSort(arr, 0, arr.size() - 1);
    // arr is now {1, 2, 3, 5, 7, 8, 9}
    for (int num : arr) {
        std::cout << num << " ";
    }
    return 0;
}
```

---

## Pivot Selection Strategies

| Strategy | Description | Performance |
|----------|-------------|-------------|
| **First element** | `pivot = arr[low]` | Poor on sorted arrays |
| **Last element** | `pivot = arr[high]` | Poor on sorted arrays |
| **Middle element** | `pivot = arr[mid]` | Better average case |
| **Random** | `pivot = arr[random]` | Best average case |
| **Median-of-three** | Median of first, middle, last | Very good |

### Random Pivot (Recommended)

```multi
[javascript]
function partitionRandom(arr, low, high) {
    // Randomized partition to avoid worst case
    const randIdx = Math.floor(Math.random() * (high - low + 1)) + low;
    [arr[randIdx], arr[high]] = [arr[high], arr[randIdx]];
    return partition(arr, low, high);
}

[python]
import random

def partition_random(arr, low, high):
    """Randomized partition to avoid worst case"""
    rand_idx = random.randint(low, high)
    arr[rand_idx], arr[high] = arr[high], arr[rand_idx]
    return partition(arr, low, high)

[java]
import java.util.Random;

private static int partitionRandom(int[] arr, int low, int high) {
    Random rand = new Random();
    int randIdx = rand.nextInt(high - low + 1) + low;
    swap(arr, randIdx, high);
    return partition(arr, low, high);
}

[cpp]
#include <cstdlib>

int partitionRandom(std::vector<int>& arr, int low, int high) {
    int randIdx = low + rand() % (high - low + 1);
    std::swap(arr[randIdx], arr[high]);
    return partition(arr, low, high);
}
```

### Median-of-Three

```multi
[javascript]
function medianOfThree(arr, low, high) {
    const mid = Math.floor((low + high) / 2);
    
    if (arr[low] > arr[mid]) [arr[low], arr[mid]] = [arr[mid], arr[low]];
    if (arr[low] > arr[high]) [arr[low], arr[high]] = [arr[high], arr[low]];
    if (arr[mid] > arr[high]) [arr[mid], arr[high]] = [arr[high], arr[mid]];
    
    // Median is now at mid, move to high-1
    [arr[mid], arr[high - 1]] = [arr[high - 1], arr[mid]];
    return arr[high - 1];
}

[python]
def median_of_three(arr, low, high):
    """Select median of first, middle, last as pivot"""
    mid = (low + high) // 2
    
    if arr[low] > arr[mid]:
        arr[low], arr[mid] = arr[mid], arr[low]
    if arr[low] > arr[high]:
        arr[low], arr[high] = arr[high], arr[low]
    if arr[mid] > arr[high]:
        arr[mid], arr[high] = arr[high], arr[mid]
    
    # Median is now at mid, move to high-1
    arr[mid], arr[high - 1] = arr[high - 1], arr[mid]
    return arr[high - 1]

[java]
private static int medianOfThree(int[] arr, int low, int high) {
    int mid = (low + high) / 2;
    
    if (arr[low] > arr[mid]) swap(arr, low, mid);
    if (arr[low] > arr[high]) swap(arr, low, high);
    if (arr[mid] > arr[high]) swap(arr, mid, high);
    
    // Median is now at mid, move to high-1
    swap(arr, mid, high - 1);
    return arr[high - 1];
}

[cpp]
int medianOfThree(std::vector<int>& arr, int low, int high) {
    int mid = (low + high) / 2;
    
    if (arr[low] > arr[mid]) std::swap(arr[low], arr[mid]);
    if (arr[low] > arr[high]) std::swap(arr[low], arr[high]);
    if (arr[mid] > arr[high]) std::swap(arr[mid], arr[high]);
    
    // Median is now at mid, move to high-1
    std::swap(arr[mid], arr[high - 1]);
    return arr[high - 1];
}
```

---

## Time & Space Complexity

| Case | Time | Space | When? |
|------|------|-------|-------|
| **Best** | O(n log n) | O(log n) | Balanced partitions |
| **Average** | O(n log n) | O(log n) | Random data |
| **Worst** | O(n²) | O(n) | Already sorted, bad pivot |

---

## Three-Way Partition (Dutch National Flag)

Handles duplicates efficiently by partitioning into three parts.

```multi
[javascript]
function quickSort3Way(arr, low = 0, high = arr.length - 1) {
    if (low >= high) return arr;
    
    let lt = low;      // arr[low..lt-1] < pivot
    let gt = high;     // arr[gt+1..high] > pivot
    let i = low + 1;   // arr[lt..i-1] == pivot
    const pivot = arr[low];
    
    while (i <= gt) {
        if (arr[i] < pivot) {
            [arr[lt], arr[i]] = [arr[i], arr[lt]];
            lt++;
            i++;
        } else if (arr[i] > pivot) {
            [arr[gt], arr[i]] = [arr[i], arr[gt]];
            gt--;
        } else {
            i++;
        }
    }
    
    quickSort3Way(arr, low, lt - 1);
    quickSort3Way(arr, gt + 1, high);
    return arr;
}

[python]
def quick_sort_3way(arr, low=0, high=None):
    """
    Handle duplicates efficiently.
    Partitions into: [< pivot] [= pivot] [> pivot]
    """
    if high is None:
        high = len(arr) - 1
    
    if low >= high:
        return arr
    
    lt = low      # arr[low..lt-1] < pivot
    gt = high     # arr[gt+1..high] > pivot
    i = low + 1   # arr[lt..i-1] == pivot
    pivot = arr[low]
    
    while i <= gt:
        if arr[i] < pivot:
            arr[lt], arr[i] = arr[i], arr[lt]
            lt += 1
            i += 1
        elif arr[i] > pivot:
            arr[gt], arr[i] = arr[i], arr[gt]
            gt -= 1
        else:
            i += 1
    
    quick_sort_3way(arr, low, lt - 1)
    quick_sort_3way(arr, gt + 1, high)
    return arr

[java]
public static void quickSort3Way(int[] arr, int low, int high) {
    if (low >= high) return;
    
    int lt = low;      // arr[low..lt-1] < pivot
    int gt = high;     // arr[gt+1..high] > pivot
    int i = low + 1;   // arr[lt..i-1] == pivot
    int pivot = arr[low];
    
    while (i <= gt) {
        if (arr[i] < pivot) {
            swap(arr, lt++, i++);
        } else if (arr[i] > pivot) {
            swap(arr, i, gt--);
        } else {
            i++;
        }
    }
    
    quickSort3Way(arr, low, lt - 1);
    quickSort3Way(arr, gt + 1, high);
}

[cpp]
void quickSort3Way(std::vector<int>& arr, int low, int high) {
    if (low >= high) return;
    
    int lt = low;      // arr[low..lt-1] < pivot
    int gt = high;     // arr[gt+1..high] > pivot
    int i = low + 1;   // arr[lt..i-1] == pivot
    int pivot = arr[low];
    
    while (i <= gt) {
        if (arr[i] < pivot) {
            std::swap(arr[lt++], arr[i++]);
        } else if (arr[i] > pivot) {
            std::swap(arr[i], arr[gt--]);
        } else {
            i++;
        }
    }
    
    quickSort3Way(arr, low, lt - 1);
    quickSort3Way(arr, gt + 1, high);
}
```

---

## Quick Select (Kth Smallest Element)

Find kth smallest element in O(n) average time using partitioning.

```multi
[javascript]
function quickSelect(arr, k) {
    function select(left, right, kSmallest) {
        if (left === right) return arr[left];
        
        const pivotIdx = partition(arr, left, right);
        
        if (kSmallest === pivotIdx) {
            return arr[kSmallest];
        } else if (kSmallest < pivotIdx) {
            return select(left, pivotIdx - 1, kSmallest);
        } else {
            return select(pivotIdx + 1, right, kSmallest);
        }
    }
    
    return select(0, arr.length - 1, k - 1);
}

// Find 3rd smallest
const arr = [7, 4, 6, 3, 9, 1];
console.log(quickSelect(arr, 3));  // 4

[python]
def quick_select(arr, k):
    """
    Find kth smallest element in O(n) average time.
    Uses partitioning without full sorting.
    """
    def select(left, right, k_smallest):
        if left == right:
            return arr[left]
        
        pivot_idx = partition(arr, left, right)
        
        if k_smallest == pivot_idx:
            return arr[k_smallest]
        elif k_smallest < pivot_idx:
            return select(left, pivot_idx - 1, k_smallest)
        else:
            return select(pivot_idx + 1, right, k_smallest)
    
    return select(0, len(arr) - 1, k - 1)

# Find 3rd smallest
arr = [7, 4, 6, 3, 9, 1]
print(quick_select(arr, 3))  # 4

[java]
public static int quickSelect(int[] arr, int k) {
    return select(arr, 0, arr.length - 1, k - 1);
}

private static int select(int[] arr, int left, int right, int kSmallest) {
    if (left == right) return arr[left];
    
    int pivotIdx = partition(arr, left, right);
    
    if (kSmallest == pivotIdx) {
        return arr[kSmallest];
    } else if (kSmallest < pivotIdx) {
        return select(arr, left, pivotIdx - 1, kSmallest);
    } else {
        return select(arr, pivotIdx + 1, right, kSmallest);
    }
}

// Find 3rd smallest
int[] arr = {7, 4, 6, 3, 9, 1};
System.out.println(quickSelect(arr, 3));  // 4

[cpp]
int quickSelect(std::vector<int>& arr, int k) {
    std::function<int(int, int, int)> select = [&](int left, int right, int kSmallest) {
        if (left == right) return arr[left];
        
        int pivotIdx = partition(arr, left, right);
        
        if (kSmallest == pivotIdx) {
            return arr[kSmallest];
        } else if (kSmallest < pivotIdx) {
            return select(left, pivotIdx - 1, kSmallest);
        } else {
            return select(pivotIdx + 1, right, kSmallest);
        }
    };
    
    return select(0, arr.size() - 1, k - 1);
}

// Find 3rd smallest
std::vector<int> arr = {7, 4, 6, 3, 9, 1};
std::cout << quickSelect(arr, 3) << std::endl;  // 4
```

---

## Quick Sort vs Other Sorts

| Feature | Quick Sort | Merge Sort | Heap Sort |
|---------|------------|------------|-----------|
| Average Time | O(n log n) | O(n log n) | O(n log n) |
| Worst Time | O(n²) | O(n log n) | O(n log n) |
| Space | O(log n) | O(n) | O(1) |
| Stable | No | Yes | No |
| In-place | Yes | No | Yes |
| Cache | Excellent | Good | Poor |

---

## Key Takeaways

1. **Divide & Conquer** - Split array around pivot, sort recursively
2. **In-place** - O(log n) space (just recursion stack)
3. **Not stable** - Equal elements may be reordered
4. **Use randomized pivot** - Avoids O(n²) on sorted input
5. **Best for general purpose** - Usually fastest in practice
6. **Worst case O(n²)** - Use median-of-three or random pivot
