# Binary Search Tree (BST)

A Binary Search Tree is a node-based binary tree data structure where each node has at most two children, and for each node: all values in the left subtree are smaller, and all values in the right subtree are larger.

## Properties

- **Left subtree** of a node contains only nodes with keys lesser than the node's key
- **Right subtree** of a node contains only nodes with keys greater than the node's key
- Both the left and right subtrees must also be binary search trees

## Visual Representation

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

Inorder traversal: 1, 3, 4, 6, 7, 8, 10, 13, 14 (sorted!)
```

## Node Structure

```multi
[javascript]
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

[python]
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

[java]
public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

[cpp]
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

## Operations

### Search - O(log n) average, O(n) worst

```multi
[javascript]
function search(root, val) {
    if (!root || root.val === val) {
        return root;
    }
    if (val < root.val) {
        return search(root.left, val);
    }
    return search(root.right, val);
}

// Iterative version
function searchIterative(root, val) {
    while (root && root.val !== val) {
        root = val < root.val ? root.left : root.right;
    }
    return root;
}

[python]
def search(root, val):
    if not root or root.val == val:
        return root
    if val < root.val:
        return search(root.left, val)
    return search(root.right, val)

# Iterative version
def search_iterative(root, val):
    while root and root.val != val:
        root = root.left if val < root.val else root.right
    return root

[java]
public TreeNode search(TreeNode root, int val) {
    if (root == null || root.val == val) {
        return root;
    }
    if (val < root.val) {
        return search(root.left, val);
    }
    return search(root.right, val);
}

// Iterative version
public TreeNode searchIterative(TreeNode root, int val) {
    while (root != null && root.val != val) {
        root = val < root.val ? root.left : root.right;
    }
    return root;
}

[cpp]
TreeNode* search(TreeNode* root, int val) {
    if (!root || root->val == val) {
        return root;
    }
    if (val < root->val) {
        return search(root->left, val);
    }
    return search(root->right, val);
}

// Iterative version
TreeNode* searchIterative(TreeNode* root, int val) {
    while (root && root->val != val) {
        root = val < root->val ? root->left : root->right;
    }
    return root;
}
```

### Insert - O(log n) average, O(n) worst

```multi
[javascript]
function insert(root, val) {
    if (!root) {
        return new TreeNode(val);
    }
    if (val < root.val) {
        root.left = insert(root.left, val);
    } else {
        root.right = insert(root.right, val);
    }
    return root;
}

// Iterative version
function insertIterative(root, val) {
    const newNode = new TreeNode(val);
    if (!root) return newNode;
    
    let curr = root;
    while (true) {
        if (val < curr.val) {
            if (!curr.left) {
                curr.left = newNode;
                break;
            }
            curr = curr.left;
        } else {
            if (!curr.right) {
                curr.right = newNode;
                break;
            }
            curr = curr.right;
        }
    }
    return root;
}

[python]
def insert(root, val):
    if not root:
        return TreeNode(val)
    if val < root.val:
        root.left = insert(root.left, val)
    else:
        root.right = insert(root.right, val)
    return root

# Iterative version
def insert_iterative(root, val):
    new_node = TreeNode(val)
    if not root:
        return new_node
    
    curr = root
    while True:
        if val < curr.val:
            if not curr.left:
                curr.left = new_node
                break
            curr = curr.left
        else:
            if not curr.right:
                curr.right = new_node
                break
            curr = curr.right
    return root

[java]
public TreeNode insert(TreeNode root, int val) {
    if (root == null) {
        return new TreeNode(val);
    }
    if (val < root.val) {
        root.left = insert(root.left, val);
    } else {
        root.right = insert(root.right, val);
    }
    return root;
}

[cpp]
TreeNode* insert(TreeNode* root, int val) {
    if (!root) {
        return new TreeNode(val);
    }
    if (val < root->val) {
        root->left = insert(root->left, val);
    } else {
        root->right = insert(root->right, val);
    }
    return root;
}
```

### Delete - O(log n) average, O(n) worst

```multi
[javascript]
function deleteNode(root, val) {
    if (!root) return null;
    
    if (val < root.val) {
        root.left = deleteNode(root.left, val);
    } else if (val > root.val) {
        root.right = deleteNode(root.right, val);
    } else {
        // Node to delete found
        if (!root.left) return root.right;
        if (!root.right) return root.left;
        
        // Node has two children: find inorder successor
        let successor = root.right;
        while (successor.left) {
            successor = successor.left;
        }
        root.val = successor.val;
        root.right = deleteNode(root.right, successor.val);
    }
    
    return root;
}

[python]
def delete(root, val):
    if not root:
        return None
    
    if val < root.val:
        root.left = delete(root.left, val)
    elif val > root.val:
        root.right = delete(root.right, val)
    else:
        # Node to delete found
        if not root.left:
            return root.right
        if not root.right:
            return root.left
        
        # Node has two children: find inorder successor
        successor = root.right
        while successor.left:
            successor = successor.left
        root.val = successor.val
        root.right = delete(root.right, successor.val)
    
    return root

[java]
public TreeNode deleteNode(TreeNode root, int val) {
    if (root == null) return null;
    
    if (val < root.val) {
        root.left = deleteNode(root.left, val);
    } else if (val > root.val) {
        root.right = deleteNode(root.right, val);
    } else {
        // Node to delete found
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        
        // Node has two children: find inorder successor
        TreeNode successor = root.right;
        while (successor.left != null) {
            successor = successor.left;
        }
        root.val = successor.val;
        root.right = deleteNode(root.right, successor.val);
    }
    
    return root;
}

[cpp]
TreeNode* deleteNode(TreeNode* root, int val) {
    if (!root) return nullptr;
    
    if (val < root->val) {
        root->left = deleteNode(root->left, val);
    } else if (val > root->val) {
        root->right = deleteNode(root->right, val);
    } else {
        // Node to delete found
        if (!root->left) return root->right;
        if (!root->right) return root->left;
        
        // Node has two children: find inorder successor
        TreeNode* successor = root->right;
        while (successor->left) {
            successor = successor->left;
        }
        root->val = successor->val;
        root->right = deleteNode(root->right, successor->val);
    }
    
    return root;
}
```

## Traversals

```multi
[javascript]
// Inorder (Left, Root, Right) - Sorted Order
function inorder(root, result = []) {
    if (root) {
        inorder(root.left, result);
        result.push(root.val);
        inorder(root.right, result);
    }
    return result;
}

// Preorder (Root, Left, Right)
function preorder(root, result = []) {
    if (root) {
        result.push(root.val);
        preorder(root.left, result);
        preorder(root.right, result);
    }
    return result;
}

// Postorder (Left, Right, Root)
function postorder(root, result = []) {
    if (root) {
        postorder(root.left, result);
        postorder(root.right, result);
        result.push(root.val);
    }
    return result;
}

[python]
# Inorder (Left, Root, Right) - Sorted Order
def inorder(root, result=None):
    if result is None:
        result = []
    if root:
        inorder(root.left, result)
        result.append(root.val)
        inorder(root.right, result)
    return result

# Preorder (Root, Left, Right)
def preorder(root, result=None):
    if result is None:
        result = []
    if root:
        result.append(root.val)
        preorder(root.left, result)
        preorder(root.right, result)
    return result

# Postorder (Left, Right, Root)
def postorder(root, result=None):
    if result is None:
        result = []
    if root:
        postorder(root.left, result)
        postorder(root.right, result)
        result.append(root.val)
    return result

[java]
// Inorder (Left, Root, Right) - Sorted Order
public List<Integer> inorder(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    inorderHelper(root, result);
    return result;
}

private void inorderHelper(TreeNode root, List<Integer> result) {
    if (root != null) {
        inorderHelper(root.left, result);
        result.add(root.val);
        inorderHelper(root.right, result);
    }
}

// Preorder and Postorder follow similar pattern

[cpp]
// Inorder (Left, Root, Right) - Sorted Order
void inorder(TreeNode* root, std::vector<int>& result) {
    if (root) {
        inorder(root->left, result);
        result.push_back(root->val);
        inorder(root->right, result);
    }
}

// Preorder (Root, Left, Right)
void preorder(TreeNode* root, std::vector<int>& result) {
    if (root) {
        result.push_back(root->val);
        preorder(root->left, result);
        preorder(root->right, result);
    }
}
```

## Common Problems

### Validate BST

```multi
[javascript]
function isValidBST(root, min = -Infinity, max = Infinity) {
    if (!root) return true;
    if (root.val <= min || root.val >= max) return false;
    
    return isValidBST(root.left, min, root.val) && 
           isValidBST(root.right, root.val, max);
}

[python]
def is_valid_bst(root, min_val=float('-inf'), max_val=float('inf')):
    if not root:
        return True
    if root.val <= min_val or root.val >= max_val:
        return False
    
    return (is_valid_bst(root.left, min_val, root.val) and
            is_valid_bst(root.right, root.val, max_val))

[java]
public boolean isValidBST(TreeNode root) {
    return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

private boolean isValid(TreeNode root, long min, long max) {
    if (root == null) return true;
    if (root.val <= min || root.val >= max) return false;
    
    return isValid(root.left, min, root.val) && 
           isValid(root.right, root.val, max);
}

[cpp]
bool isValidBST(TreeNode* root, long min = LONG_MIN, long max = LONG_MAX) {
    if (!root) return true;
    if (root->val <= min || root->val >= max) return false;
    
    return isValidBST(root->left, min, root->val) && 
           isValidBST(root->right, root->val, max);
}
```

### Kth Smallest Element

```multi
[javascript]
function kthSmallest(root, k) {
    const stack = [];
    let current = root;
    let count = 0;
    
    while (current || stack.length > 0) {
        while (current) {
            stack.push(current);
            current = current.left;
        }
        
        current = stack.pop();
        count++;
        
        if (count === k) {
            return current.val;
        }
        
        current = current.right;
    }
    
    return -1;
}

[python]
def kth_smallest(root, k):
    stack = []
    current = root
    count = 0
    
    while current or stack:
        while current:
            stack.append(current)
            current = current.left
        
        current = stack.pop()
        count += 1
        
        if count == k:
            return current.val
        
        current = current.right
    
    return -1

[java]
public int kthSmallest(TreeNode root, int k) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode current = root;
    int count = 0;
    
    while (current != null || !stack.isEmpty()) {
        while (current != null) {
            stack.push(current);
            current = current.left;
        }
        
        current = stack.pop();
        count++;
        
        if (count == k) {
            return current.val;
        }
        
        current = current.right;
    }
    
    return -1;
}

[cpp]
int kthSmallest(TreeNode* root, int k) {
    std::stack<TreeNode*> stk;
    TreeNode* current = root;
    int count = 0;
    
    while (current || !stk.empty()) {
        while (current) {
            stk.push(current);
            current = current->left;
        }
        
        current = stk.top();
        stk.pop();
        count++;
        
        if (count == k) {
            return current->val;
        }
        
        current = current->right;
    }
    
    return -1;
}
```

### Lowest Common Ancestor

```multi
[javascript]
function lowestCommonAncestor(root, p, q) {
    while (root) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else {
            return root;
        }
    }
    return null;
}

[python]
def lowest_common_ancestor(root, p, q):
    while root:
        if p.val < root.val and q.val < root.val:
            root = root.left
        elif p.val > root.val and q.val > root.val:
            root = root.right
        else:
            return root
    return None

[java]
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while (root != null) {
        if (p.val < root.val && q.val < root.val) {
            root = root.left;
        } else if (p.val > root.val && q.val > root.val) {
            root = root.right;
        } else {
            return root;
        }
    }
    return null;
}

[cpp]
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    while (root) {
        if (p->val < root->val && q->val < root->val) {
            root = root->left;
        } else if (p->val > root->val && q->val > root->val) {
            root = root->right;
        } else {
            return root;
        }
    }
    return nullptr;
}
```

## Time Complexity

| Operation | Average  | Worst Case |
| --------- | -------- | ---------- |
| Search    | O(log n) | O(n)       |
| Insert    | O(log n) | O(n)       |
| Delete    | O(log n) | O(n)       |

**Note:** Worst case occurs with skewed trees (degenerates to linked list).

## Key Takeaways

1. **BST Property** - Left subtree < Node < Right subtree
2. **Inorder traversal** gives sorted order
3. **O(log n) average** for all operations
4. **Worst case O(n)** when tree becomes skewed
5. Use **AVL or Red-Black trees** for guaranteed balance
