# Kruskal's Algorithm

Kruskal's algorithm finds the Minimum Spanning Tree (MST) of a connected, undirected, weighted graph. It uses a greedy approach.

## What is MST?

A Minimum Spanning Tree connects all vertices with the minimum total edge weight, using exactly V-1 edges.

```
Graph:                          MST:
    A ---4--- B                    A ---4--- B
    |\       /|                              |
   1| \3   2/ |5                  1          |2
    |  \   /  |                    |         |
    C ---2--- D                    C ---2--- D

Original edges: A-B(4), A-C(1), A-D(3), B-D(2), C-D(2), B-D(5)
MST edges: A-C(1), C-D(2), B-D(2) → Total weight: 5
```

## How It Works

1. Sort all edges by weight
2. For each edge (in order):
   - If adding it doesn't create a cycle, include it
   - Use Union-Find to detect cycles
3. Stop when we have V-1 edges

## Implementation

```multi
[javascript]
class UnionFind {
    constructor(n) {
        this.parent = Array.from({ length: n }, (_, i) => i);
        this.rank = new Array(n).fill(0);
    }
    
    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x, y) {
        const px = this.find(x);
        const py = this.find(y);
        if (px === py) return false;
        
        if (this.rank[px] < this.rank[py]) {
            this.parent[px] = py;
        } else if (this.rank[px] > this.rank[py]) {
            this.parent[py] = px;
        } else {
            this.parent[py] = px;
            this.rank[px]++;
        }
        return true;
    }
}

function kruskal(n, edges) {
    // edges: array of [weight, u, v]
    edges.sort((a, b) => a[0] - b[0]);
    
    const uf = new UnionFind(n);
    const mst = [];
    let totalWeight = 0;
    
    for (const [weight, u, v] of edges) {
        if (uf.union(u, v)) {
            mst.push([u, v, weight]);
            totalWeight += weight;
            
            if (mst.length === n - 1) break;
        }
    }
    
    return { mst, totalWeight };
}

// Usage
const edges = [[4,0,1], [1,0,2], [3,0,3], [2,1,3], [2,2,3], [5,1,3]];
const result = kruskal(4, edges);
console.log(result);  // MST edges and total weight

[python]
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.rank[px] < self.rank[py]:
            px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]:
            self.rank[px] += 1
        return True

def kruskal(n, edges):
    """
    Kruskal's algorithm for Minimum Spanning Tree.
    edges: list of (weight, u, v)
    Time: O(E log E)
    """
    edges.sort()  # Sort by weight
    
    uf = UnionFind(n)
    mst = []
    total_weight = 0
    
    for weight, u, v in edges:
        if uf.union(u, v):
            mst.append((u, v, weight))
            total_weight += weight
            
            if len(mst) == n - 1:
                break
    
    return mst, total_weight

# Usage
edges = [(4,0,1), (1,0,2), (3,0,3), (2,1,3), (2,2,3), (5,1,3)]
mst, total = kruskal(4, edges)
print(f"MST: {mst}, Total weight: {total}")

[java]
class UnionFind {
    int[] parent, rank;
    
    UnionFind(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }
    
    boolean union(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;
        
        if (rank[px] < rank[py]) parent[px] = py;
        else if (rank[px] > rank[py]) parent[py] = px;
        else { parent[py] = px; rank[px]++; }
        return true;
    }
}

public class Kruskal {
    public List<int[]> kruskal(int n, int[][] edges) {
        // edges: [weight, u, v]
        Arrays.sort(edges, (a, b) -> a[0] - b[0]);
        
        UnionFind uf = new UnionFind(n);
        List<int[]> mst = new ArrayList<>();
        int totalWeight = 0;
        
        for (int[] edge : edges) {
            int weight = edge[0], u = edge[1], v = edge[2];
            if (uf.union(u, v)) {
                mst.add(new int[]{u, v, weight});
                totalWeight += weight;
                
                if (mst.size() == n - 1) break;
            }
        }
        
        return mst;
    }
}

[cpp]
class UnionFind {
    std::vector<int> parent, rank;
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        for (int i = 0; i < n; i++) parent[i] = i;
    }
    
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }
    
    bool unite(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;
        
        if (rank[px] < rank[py]) parent[px] = py;
        else if (rank[px] > rank[py]) parent[py] = px;
        else { parent[py] = px; rank[px]++; }
        return true;
    }
};

std::pair<std::vector<std::tuple<int,int,int>>, int> 
kruskal(int n, std::vector<std::tuple<int,int,int>>& edges) {
    // edges: (weight, u, v)
    std::sort(edges.begin(), edges.end());
    
    UnionFind uf(n);
    std::vector<std::tuple<int,int,int>> mst;
    int totalWeight = 0;
    
    for (auto& [weight, u, v] : edges) {
        if (uf.unite(u, v)) {
            mst.push_back({u, v, weight});
            totalWeight += weight;
            
            if (mst.size() == n - 1) break;
        }
    }
    
    return {mst, totalWeight};
}
```

## Time Complexity

| Operation | Complexity |
|-----------|------------|
| Sorting edges | O(E log E) |
| Union-Find | O(E × α(V)) ≈ O(E) |
| **Total** | **O(E log E)** |

## Comparison with Prim's Algorithm

| Feature | Kruskal's | Prim's |
|---------|-----------|--------|
| Approach | Edge-based | Vertex-based |
| Best for | Sparse graphs | Dense graphs |
| Complexity | O(E log E) | O(E log V) |
| Data structure | Union-Find | Priority Queue |

## When MST Doesn't Exist

```multi
[javascript]
function canFormMST(n, edges) {
    // Returns true if graph is connected
    const uf = new UnionFind(n);
    let components = n;
    
    for (const [weight, u, v] of edges) {
        if (uf.union(u, v)) {
            components--;
        }
    }
    
    return components === 1;
}

[python]
def can_form_mst(n, edges):
    """Returns True if graph is connected."""
    uf = UnionFind(n)
    components = n
    
    for weight, u, v in edges:
        if uf.union(u, v):
            components -= 1
    
    return components == 1

[java]
public boolean canFormMST(int n, int[][] edges) {
    UnionFind uf = new UnionFind(n);
    int components = n;
    
    for (int[] edge : edges) {
        if (uf.union(edge[1], edge[2])) {
            components--;
        }
    }
    
    return components == 1;
}

[cpp]
bool canFormMST(int n, std::vector<std::tuple<int,int,int>>& edges) {
    UnionFind uf(n);
    int components = n;
    
    for (auto& [weight, u, v] : edges) {
        if (uf.unite(u, v)) {
            components--;
        }
    }
    
    return components == 1;
}
```

## Applications

| Application | Description |
|-------------|-------------|
| **Network Design** | Minimum cable length to connect buildings |
| **Cluster Analysis** | Group similar data points |
| **Image Segmentation** | Divide image into regions |
| **Circuit Design** | Minimum wire length |
| **Road Networks** | Minimum cost to connect cities |

## Key Takeaways

1. **Greedy approach** - always pick smallest edge that doesn't create cycle
2. **Uses Union-Find** - efficient cycle detection with path compression
3. **O(E log E) time** - dominated by sorting step
4. **Best for sparse graphs** - fewer edges to sort
5. **Produces V-1 edges** - exactly what's needed for spanning tree
